<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="loody's blog">
<meta property="og:url" content="http://loody.github.io/index.html">
<meta property="og:site_name" content="loody's blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="loody's blog">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> loody's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?f99c8e8fc92fd70fbf50a1494cf47607";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">loody's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/20/说说Handler的工作原理/" itemprop="url">
                  说说Handler的工作原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-20T21:58:48+08:00" content="2016-03-20">
              2016-03-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/20/说说Handler的工作原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/20/说说Handler的工作原理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><p>我们知道，Android系统是<strong>单线程模型</strong>，即应用程序启动时，系统会创建一个主线程，又叫做UI线程，负责与UI组件（进行交互，比如控制UI界面界面显示、更新等，UI线程只能处理一些简单的、短暂的操作，如果要执行繁重的任务或者耗时很长的操作，比如访问网络、数据库、下载等，这种<strong>单线程模型</strong>会导致线程运行性能大大降低，甚至阻塞UI线程，如果被阻塞超过5秒，系统会提示应用程序无相应对话框，即ANR，导致退出整个应用程序或者短暂杀死应用程序,所以Android系统将大部分耗时、繁重任务交给子线程完成，不会在主线程中完成；同时，Android只允许主线程更新UI界面，子线程处理后的结果无法和主线程交互，即无法直接访问主线程，这就要用到<strong>Handler机制</strong>来解决此问题</p>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>在我们在子线程中执行完耗时操作后很多情况下我们需要更新UI，但我们都知道，不能在子线程中更新UI。此时最常用的手段就是通过Handler将一个Message消息send到UI线程中，然后再在Handler的handleMessage方法中进行处理,常见代码</p>
<pre><code>private Handler mHandle = new Handler(){
    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        switch (msg.what){
            case xx:
                break;

        }
    }
};

new Thread() {
    @Override
    public void run() {
        super.run();
        //耗时操作
        Message msg = new Message();
        msg.what = WHAT;
        mHandle.sendMessage(msg);
    }
}.start(); 
</code></pre><p>每个Handler都会关联一个消息队列，消息队列被封装在Lopper中，而每个Looper又会关联一个线程(ThreadLocal)，也就是每个消息队列会关联一个线程。Handler就是一个消息处理器，将消息投递给消息队列，然后再由对应的线程从消息队列中挨个取出消息，并且执行。默认情况下，消息队列只有一个，即主线程的消息队列，这个消息队列是在<a href="http://blog.csdn.net/luoshengyang/article/details/6747696" target="_blank" rel="external">系统的启动过程中</a>的ActivityThread.main方法中创建的，通过Lopper.prepareMainLooper()来创建，然后最后执行Looper.loop()来启动消息循环。那么我们为什么在平时的使用Handler的时候，并没有使用Looper呀，其实是因为系统为我们创建好了，我们可以查看ActivityThread.java来看看这个过程，只列了关键代码：</p>
<pre><code>public final class ActivityThread {
......

public static final void main(String[] args) {
    ...

    Looper.prepareMainLooper();// 1、创建消息循环Looper  
    if (sMainThreadHandler == null) {
        sMainThreadHandler = new Handler(); // 主线程的Handler 
    }

    ActivityThread thread = new ActivityThread();
    thread.attach(false);

    if (false) {
        Looper.myLooper().setMessageLogging(new
            LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));
    }
    Looper.loop();// 2、执行消息循环

    if (Process.supportsProcesses()) {
        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
    }

    thread.detach();
    ...
}

......
</code></pre><p>}</p>
<p>通过上面的原理介绍，我们可以画出下面这个流程图</p>
<p><img src="/images/handler-1.jpg" alt=""></p>
<p>那么它们具体是怎么协作的呢？下面我们通过源码一步步解析，首先看下Handler</p>
<pre><code>/**
 * Default constructor associates this handler with the {@link Looper} for the
 * current thread.
 *
 * If this thread does not have a looper, this handler won&apos;t be able to receive messages
 * so an exception is thrown.
 */
public Handler() {
    this(null, false);
}

public Handler(Callback callback, boolean async) {
    if (FIND_POTENTIAL_LEAKS) {
        final Class&lt;? extends Handler&gt; klass = getClass();
        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                klass.getCanonicalName());
        }
    }

    mLooper = Looper.myLooper();   // 获取Looper
    if (mLooper == null) {
        throw new RuntimeException(
            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);
    }
    mQueue = mLooper.mQueue;       // 获取消息队列
    mCallback = null;
}
</code></pre><p>从Handler默认的构造函数中我们可以看到，Handler会在内部通过Looper.getLooper()来获取Looper对象，并且与之关联，那么Looper.myLooper又是如何工作的呢？我们继续往下看.</p>
<pre><code>/**
 * Return the Looper object associated with the current thread.  Returns
 * null if the calling thread is not associated with a Looper.
 */
public static Looper myLooper() {
    return sThreadLocal.get();
}

/**
 * Initialize the current thread as a looper, marking it as an
 * application&apos;s main looper. The main looper for your application
 * is created by the Android environment, so you should never need
 * to call this function yourself.  See also: {@link #prepare()}
 */
public static void prepareMainLooper() {
    prepare();
    setMainLooper(myLooper());
    myLooper().mQueue.mQuitAllowed = false;
}

private synchronized static void setMainLooper(Looper looper) {
    mMainLooper = looper;
}

 /** Initialize the current thread as a looper.
  * This gives you a chance to create handlers that then reference
  * this looper, before actually starting the loop. Be sure to call
  * {@link #loop()} after calling this method, and end it by calling
  * {@link #quit()}.
  */
public static void prepare() {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
    }
    sThreadLocal.set(new Looper());
}
</code></pre><p> 我们看到myLooper()方法是通过sThreadLocal.get()来获取的，上面也提到，在ActivityThread.main方法中会调用<code>prepareMainLooper()</code>方法，prepareMainLooper中执行了<code>prepare</code>，<code>prepare</code>中会创建一个Looper并赋值给 <code>sThreadLocal</code>，这样Looper就和线程关联上了，而且有一点很重要，普通的线程是没有looper的，如果需要looper对象，那么必须要先调用Looper.prepare()方法，而且一个线程只能有一个looper ，而在Handler中，消息队列通过Looper与线程关联，而Handler又与Looper关联，因此Handler最终就和线程、线程的消息队列关联上了，那么创建了Looper后，是如何执行消息循环呢？我们来看下<code>Looper.loop()</code>方法</p>
<h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><pre><code>public static void loop() {
    final Looper me = myLooper();//获取looper对象
    if (me == null) {
        //若为空则说明当前线程不是LooperThread，抛出异常
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);
    }
    final MessageQueue queue = me.mQueue; 获取消息队列
    .....
    for (;;) {
        //死循环不断取出消息
        Message msg = queue.next(); // might block 
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

        // This must be in a local variable, in case a UI event sets the logger
        //打印log，说明开始处理message。msg.target就是Handler对象
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                    msg.callback + &quot;: &quot; + msg.what);
        }

        //开始处理message，msg.target就是Handler对象
        msg.target.dispatchMessage(msg);

        .....
    }
}
</code></pre><p>很明显，就是一个大的循环，不断从消息队列出取出消息。然后调用一个很关键的方法msg.target.dispatchMessage(msg)开始处理消息。msg.target就是message对应的handler，所以对于Looper，我们结论就是通过Looper.prepare()来创建Looper对象(消息队列封装在Looper对象中)，并且保存在sThreadLoal中，然后通过Looper.loop()来执行消息循环，这两步通常是成对出现的！</p>
<h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>最后我们看看消息处理机制，先看看Message</p>
<pre><code>public final class Message implements Parcelable {

    public int what;

    public int arg1; 

    public int arg2;

    public Object obj;


    int flags;

    long when;

    Bundle data;

    Handler target;         // target处理

    Runnable callback;      // Runnable类型的callback

    // sometimes we store linked lists of these things
       Message next;           // 下一条消息，消息队列是链式存储的

    ....
}
</code></pre><p>前面说到loop循环中处理信息的msg.target.dispatchMessage(msg)方法。现在我们来看下这个方法的源码</p>
<pre><code>public void dispatchMessage(Message msg) {
    //注意！这里先判断message的callback是否为空，否则就直接处理message的回调函数
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            //正是在这调用我们平常重写handleMessage
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}
</code></pre><p>这里为什么要先判断<code>msg.callback！=null呢</code>，因为<code>post(Runnable r)</code>方法也能用来处理事件</p>
<pre><code>public final boolean post(Runnable r){
    //获取消息并发送给消息队列
    return  sendMessageDelayed(getPostMessage(r), 0);
}

private final Message getPostMessage(Runnable r) {  
    Message m = Message.obtain();  
    m.callback = r;  
    return m;  
}
</code></pre><p>在post(Runnable r)时，会将Runnable包装成Message对象，并且将Runnable对象设置给Message对象的callback字段，最后会将该Message对象插入消息队列。</p>
<p>至此，Handler的工作原理就说完了。    </p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/12/初识groovy/" itemprop="url">
                  初识Groovy
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-12T23:29:32+08:00" content="2016-03-12">
              2016-03-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Groovy/" itemprop="url" rel="index">
                    <span itemprop="name">Groovy</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/12/初识groovy/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/12/初识groovy/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Groovy概述"><a href="#Groovy概述" class="headerlink" title="Groovy概述"></a>Groovy概述</h2><p>Groovy是Java平台上设计的面向对象编程语言。这门动态语言拥有类似Python、Ruby和Smalltalk中的一些特性，可以作为Java平台的脚本语言使用。</p>
<p>Groovy的语法与Java非常相似，以至于多数的Java代码也是正确的Groovy代码。Groovy代码动态的被编译器转换成Java字节码。由于其运行在JVM上的特性，Groovy可以使用其他Java语言编写的库。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通过Homebrew安装：</p>
<pre><code>brew install groovy
</code></pre><p>安装结束后，测试一下：</p>
<pre><code>groovy -version
</code></pre><p>上面为Mac OS X上的安装方法，其他平台的安装方式请参考 <a href="http://www.groovy-lang.org/install.html" target="_blank" rel="external">groovy install</a></p>
<p>我们新建一个例子，命名test.groovy,里面输入这样一句话：</p>
<pre><code>printlin &quot;hellow word&quot;
</code></pre><p>在终端上执行这个文件：</p>
<pre><code>groovy test.groovy
</code></pre><p>结果：</p>
<p><img src="/images/groovy-1.png" alt=""></p>
<p>如果我们用java来打印这段话，代码是这样的：</p>
<pre><code>public class HelloWorld {
     public static void main(String[] args) {
          System.out.println(&quot;Hello World&quot;)
      }
}
</code></pre><p>对比一下，groovy是不是简单太多了</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>Groovy中支持动态类型，变量定义可以使用关键字<code>def</code>，即定义变量的时候可以不指定其类型。groovy会根据’=’右边的类型自动判断，比如我们定义一个变量value</p>
<pre><code>def value = &quot;hello,groovy&quot; //结尾没有分号
println value.class //输入value的类型
</code></pre><p>输出是</p>
<pre><code>class java.lang.String
</code></pre><p>继续赋值</p>
<pre><code>def value = &quot;hello,groovy&quot; 
println value
println value.class
value = 1 //直接赋值另外一个数据类型 没有重新申明
println value
println value.class
</code></pre><p>输出是</p>
<pre><code>hello,groovy
class java.lang.String
1
class java.lang.Integer
</code></pre><p>可以看出，在groovy里，我们在运行时可以改变变量的数据类型</p>
<p>##数据类型<br>作为动态语言，Groovy世界中的所有事物都是对象。所以，int，boolean这些Java中的基本数据类型，在Groovy代码中其实对应的是它们的包装数据类型。比如int对应为Integer，boolean对应为Boolean</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>groovy中容器有三种</p>
<blockquote>
<p>List：链表，其底层对应Java中的List接口，一般用ArrayList作为真正的实现类。<br>Map：键-值表，其底层对应Java中的LinkedHashMap。<br>Range：范围，它其实是List的一种拓展。    </p>
</blockquote>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List变量由[]定义，比如  </p>
<pre><code>def list = [5,&apos;string&apos;,true] //List由[]定义，其元素可以是任何对象  
</code></pre><p>变量存取：可以直接通过索引存取，而且不用担心索引越界。如果索引超过当前链表长度，List会自动往该索引添加元素</p>
<pre><code>list[5] = &quot;hello&quot;
list[100] = 100
println list[5] 
println list[100] 
println list.size  
</code></pre><p>分别输出 <code>hello</code>,<code>100</code>,<code>101</code>    </p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>java中的map</p>
<pre><code>Map&lt;String, String&gt;map = new HashMap&lt;String, String&gt;();
map.put(&quot;name&quot;, &quot;mary&quot;);
map.put(&quot;age&quot;,&quot;25&quot;);
</code></pre><p>groovy定义:Map由[:]定义，注意其中的冒号。冒号左边是key，右边是Value。key必须是字符串，value可以是任何对象。另外，key可以用’’或””包起来，也可以不用引号包起来</p>
<pre><code>def map = [&quot;name&quot;:&quot;mary&quot;,&quot;age&quot;:25]
</code></pre><p>也可以这样写</p>
<pre><code>def map = [name:&quot;mary&quot;,age:25] //Groovy 映射中的键不必是 String。在这个示例中，name 看起来像一个变量，但是在幕后，Groovy 会将它变成 String。
</code></pre><p>取值也很方便</p>
<pre><code>map.name
map[&quot;name&quot;]
</code></pre><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>我们先看一个用java代码实现的一个循环</p>
<pre><code>for(int i=0;i&lt;5;i++){
    System.out.println(&quot;Hello World&quot; + i);
}
</code></pre><p>打印5次<code>Hello World</code></p>
<p>用groovy怎么实现呢</p>
<pre><code>for(i=0;i&lt;5;i++){
    println &quot;Hello World&quot; + i
}
</code></pre><p>更快刚简洁的呢？</p>
<pre><code>for(i in 0..4){
    println &quot;Hello World&quot; + i
}
</code></pre><p>或</p>
<pre><code>for(i in 1..&lt;5){
    println &quot;Hello World&quot; + i
}
</code></pre><p>其中 <code>0..4</code>、<code>1..&lt;5</code>就是groovy中的range</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包，英文叫Closure，是Groovy中非常重要的一个数据类型或者说一种概念了</p>
<p>闭包的一些快捷写法，当闭包作为闭包或方法的最后一个参数。可以将闭包从参数圆括号中提取出来接在最后，如果闭包是唯一的一个参数，则闭包或方法参数所在的圆括号也可以省略。对于有多个闭包参数的，只要是在参数声明最后的，均可以按上述方式省略。例如</p>
<ol>
<li><p>没有参数</p>
<pre><code>def closure = {  
    println &quot;hello closure&quot; 
} 
</code></pre><p> //大括号括起来的<strong>代码块</strong>就是一个最简单的闭包</p>
<p> 闭包有一个隐含的参数，这个参数名字叫it，和this的作用类似</p>
<pre><code>def closure = {      
    it -&gt; println &quot;hello $it&quot; 
} 
</code></pre><p> 调用</p>
<pre><code>closure（&quot;closure&quot;）
</code></pre><p>  两种的输出结果是一样的</p>
</li>
<li><p>有参数并且最后一个参数是闭包</p>
<pre><code>def closure = {  
    String name ,int age,Closure cl -&gt;  //这个箭头很关键。箭头前面是参数定义，箭头后面是代码  
    println &quot;name is&quot; + name + &quot;, age is &quot; + age 
    cl() //这是代码，最后一句是返回值 
       //也可以使用return，和Groovy中普通函数一样  
} 
</code></pre><p> 调用的时候就可以将闭包从参数圆括号中提取出来接在最后</p>
<pre><code>closure(&quot;mary&quot;,25){
    println &quot;yes&quot;
}
</code></pre><p> 输出 </p>
<pre><code>name is mary, age is 25
yes
</code></pre></li>
</ol>
<p>我们在渠道打包的时候有一段重命名apk文件的task代码</p>
<pre><code>applicationVariants.all { variant -&gt;
    variant.outputs.each { output -&gt;
        def outputFile = output.outputFile
        if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) {
            def fileName =...
            output.outputFile = new File(outputFile.parent, fileName)
        }
    }
}
</code></pre><p>之前硬是没看懂是什么意思，现在学习了基本的groovy语法，看起来很简单嘛。</p>
<h2 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h2><p>下面这些包和类都是默认导入的，不用再显式地使用 import 语句</p>
<ul>
<li>java.io.*</li>
<li>java.lang.*</li>
<li>java.math.BigDecimal</li>
<li>java.math.BigInteger</li>
<li>java.net.*</li>
<li>java.util.*</li>
<li>groovy.lang.*</li>
<li>groovy.util.*</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>了解了基本的groovy知识后，我们应该是深入地认识到 Groovy 就是 Java，只是缺少了你过去使用的许多语法规则。Groovy 是没有类型、没有修改符、没有 return、没有 Iterator、不需要导入集合的 Java。简而言之，Groovy 就是丢掉了许多包袱的 Java。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.csdn.net/innost/article/details/48228651" target="_blank" rel="external">深入理解Android之Gradle</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/education/java/j-groovy/j-groovy.html" target="_blank" rel="external">精通groovy</a></li>
<li><a href="http://www.groovy-lang.org/api.html" target="_blank" rel="external">Groovy API</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/26/2016-02-26-android-multi- package/" itemprop="url">
                  Android多渠道打包方案介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-26T20:00:20+08:00" content="2016-02-26">
              2016-02-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/02/26/2016-02-26-android-multi- package/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/02/26/2016-02-26-android-multi- package/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  目前android应用市场不计其数，作为一名android开发者，每次发布新版的时候，都是个令人头痛的问题，为了方面渠道统计分析，我们要给每个应用市场打包，甚至，还有公司很对每个渠道还要打不同的包比如免费版、收费版，这无疑给开发者带来很多麻烦，因为每次都要花一定时间在这方面。那有没有一些工具可以帮我们提高效率呢！答案当然是有咯！</p>
<p>首先介绍下目前市场上比较广泛使用的打包方式</p>
<h2 id="gradle设置productFlavor方式"><a href="#gradle设置productFlavor方式" class="headerlink" title="gradle设置productFlavor方式"></a>gradle设置productFlavor方式</h2><p>  这种方式很早以前奇大已经推出了详细教程，这里我就不多说，大家可以移步查看<a href="http://stormzhang.com/devtools/2015/01/15/android-studio-tutorial6/" target="_blank" rel="external">Gradle多渠道打包</a>，可以说这篇教程贡献非常大，帮助很多人少走不少弯路！感谢奇大的分享！</p>
<h2 id="美团的打包方式"><a href="#美团的打包方式" class="headerlink" title="美团的打包方式"></a>美团的打包方式</h2><p>  这种方式是由<a href="http://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="external">美团技术团队</a>推出的</p>
<p>  通过解压缩apk，我们知道，其实apk包就是个zip包，zip解压缩后有一个META-INF目录，如下图：</p>
<p>  <img src="/images/apk_express.png" alt="image"></p>
<p>  他们发现如果在META-INF目录内添加空文件，可以不用重新签名应用（不要问我为什么），这样我们就可以忘这里面添加一个空文件，文件的名字包含渠道名，然后我们在项目加载的时候通过解压缩将这个渠道名从文件命中取出来，调用友盟的<code>AnalyticsConfig.setChannel(channel)</code>就可以了。这样我们只需要打一个包，然后通过在这个包基础上插入带渠道名字的空文件到各个apk的META-INF目录中就可以了，当然这个操作是通过python脚本完成的</p>
<p>  说到这里笔者要给大家填几个坑</p>
<p>  如果你用的是友盟统计，请注意了，友盟给我们提供了两种设置渠道的方式</p>
<ol>
<li><p>AndroidManifest.xml配置</p>
<pre><code>&lt;meta-data
  android:name=&quot;UMENG_CHANNEL&quot;
  android:value=&quot;Umeng&quot; &gt;
</code></pre></li>
<li><p>代码手动设置 </p>
<pre><code>AnalyticsConfig.setChannel(channel)
</code></pre><p>坑来了</p>
<ol>
<li><p>你不能同时设置两种方式，友盟技术给我的解释是他们会优先采用第一次取到的渠道名，也就是说如果你两种方式都设置了，很有可能你手动设置的值就无效了，测试下来确实如此（巨坑）</p>
</li>
<li><p>如果你只采用手动设置的方式，一定要讲设置的代码放置在Application类中。而不是放在启动的Activity里否则你就会发现后台统计到的渠道全是“<strong>unknow</strong>”、所以这点一定要注意。</p>
</li>
</ol>
</li>
</ol>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p> 说完了原理和坑，大家有没有觉得可以改进的地方呢，我们每次打完包后都要切换到相应的目录，再通过执行python脚本来网apk中插入渠道名，有没有方法可以在打包完后直接就执行python脚本呢，结果是可以的，因为我们用的是gradle打包，gradle是可以执行python命令的，我们只需要在打包完后再新建一个执行python的task，就可以了，废话不多说，上代码</p>
<p>在gradle的android porject中加入</p>
<pre><code>project.afterEvaluate {
    //在Release执行以后
    tasks.getByName(&quot;assembleRelease&quot;) {
        it.doLast {
            def fileName = &quot;secret_v&quot; + defaultConfig.versionName + &quot;_&quot; + releaseTime() + &quot;.apk&quot;
            def rApk = new File(&quot;app/build/outputs/apk/&quot; + fileName)
            if (rApk.exists()) {
                packageChannel(rApk.absolutePath)
            }
        }
    }
}
</code></pre><p>执行加入渠道名的python脚本</p>
<pre><code>def packageChannel(String releaseApk) {
    try {
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine &apos;python&apos;,         rootProject.getRootDir().getAbsolutePath() + &quot;/app/multi_build.py&quot;, releaseApk
        standardOutput = stdout
    }
        return stdout.toString().trim()
    }
    catch (ignored) {
        return &quot;UnKnown&quot;;
    }
}
</code></pre><p>multi_build.py脚本代码</p>
<pre><code>#!/usr/bin/python
# coding=utf-8
import zipfile
import shutil
import os
import datetime
import sys

# 空文件 便于写入 此空文件到apk包中作为channel文件
src_empty_file = &apos;empty.txt&apos;
# 创建一个空文件（不存在则创建）
f = open(src_empty_file, &apos;w&apos;)
f.close()


# 获取渠道列表
channel_file = &apos;channel.txt&apos;
f = open(channel_file)
lines = f.readlines()
f.close()

src_apk=sys.argv[1]

# file name (with extension)
src_apk_file_name = os.path.basename(src_apk)
print(src_apk_file_name)

# 分割文件名与后缀
temp_list = os.path.splitext(src_apk_file_name)
# name without extension
src_apk_name = temp_list[0]
# 后缀名，包含.   例如: &quot;.apk &quot;
src_apk_extension = temp_list[1]

# 创建生成目录,与文件名相关 放置在build/outputs/下,方便执行clean的时候清空历史记录
output_dir = &apos;build/outputs/&apos; + src_apk_name + &apos;/&apos;
# 目录不存在则创建
if not os.path.exists(output_dir):
    os.mkdir(output_dir)

# 遍历渠道号并创建对应渠道号的apk文件
for line in lines:
    # 获取当前渠道号，因为从渠道文件中获得带有\n,所有strip一下
    target_channel = line.strip()

    target_apk = output_dir +src_apk_name + &quot;_&quot; + target_channel + src_apk_extension

    # 拷贝建立新apk
    shutil.copy(src_apk,  target_apk)
    # zip获取新建立的apk文件
    zipped = zipfile.ZipFile(target_apk, &apos;a&apos;, zipfile.ZIP_DEFLATED)
    # 初始化渠道信息
    empty_channel_file = &quot;META-INF/channel_{channel}&quot;.format(channel = target_channel)
    # 写入渠道信息
    zipped.write(src_empty_file, empty_channel_file)
    # 关闭zip流
    zipped.close()
</code></pre><p>这样我们只需要执行 <code>./gradlew assembleRelease</code> 即可完成所有渠道的打包，时间在两分钟以内。</p>
<h2 id="gradle插件打包方式"><a href="#gradle插件打包方式" class="headerlink" title="gradle插件打包方式"></a>gradle插件打包方式</h2><p>用作者的话说就是：<a href="https://github.com/mcxiaoke/packer-ng-plugin" target="_blank" rel="external">下一代Android渠道打包工具</a></p>
<p>这种方式就是集我上面优化的美团方案于一身的另外一种打包方式，集成起来更方便，因为它是以gradle插件的方式引入项目的，所以不需要我们写python脚本.原理也跟美团的打包方式不一样<br>，具体可以参见作者的readme，写的很清楚</p>
<p>笔者已经集成到项目中打包测试过，速度也非常快，但是在一些输出目录的配置上遇到一些问题，已经给作者提issue,待作者回复了并具体可行了我会再回来写一些具体的配置方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面三种打包方案来看，显然第一种方案已经不适合进行批量打包，但是如果你的项目需要一些特性定制的话，还是需要用到第一种方式的，至于美团和gradle插件的方式，他们的打包速度都非常的快，但是从集成的角度来看，gradle插件的方式会更加方面一些，作者甚至也指出美团打包方式在解压缩apk时的性能问题，不过从我目前的项目测试来看，并没有太大问题，所以我认为这两种方式都可以作为我们项目多渠道打包的选择</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/21/2016-02-21-custom-toolbar/" itemprop="url">
                  定制你的Toolbar
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-21T20:00:20+08:00" content="2016-02-21">
              2016-02-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/02/21/2016-02-21-custom-toolbar/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/02/21/2016-02-21-custom-toolbar/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>相信大家对<a href="http://developer.android.com/intl/zh-cn/reference/android/widget/Toolbar.html" target="_blank" rel="external">Toobar</a>已经很熟悉了，这是android系统在5.0版本中推出的新控件,这里有有篇比较详细的介绍，不太明白的可以看看<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1118/2006.html/" target="_blank" rel="external">android：ToolBar详解（手把手教程）</a></p>
<p>接下来说今天的重点，怎么定制你的Toolbar</p>
<p>很多app有自己的主色(非白)，就像新建一个项目系统自动生成的默认页，如下图：<br><img src="/images/custom_toolbar_1.png" alt=""></p>
<p>我们来看一下布局代码</p>
<pre><code> &lt;android.support.design.widget.AppBarLayout
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;&gt;

    &lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/toolbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;?attr/actionBarSize&quot;
        android:background=&quot;?attr/colorPrimary&quot;
        app:popupTheme=&quot;@style/AppTheme.PopupOverlay&quot;/&gt;

&lt;/android.support.design.widget.AppBarLayout&gt;
</code></pre><p>接下来是样式</p>
<pre><code>&lt;style name=&quot;AppTheme.AppBarOverlay&quot; parent=&quot;ThemeOverlay.AppCompat.Dark.ActionBar&quot;/&gt;

   &lt;style name=&quot;AppTheme.PopupOverlay&quot; parent=&quot;ThemeOverlay.AppCompat.Light&quot;/&gt;
</code></pre><p>我们给</p>
<p><code>AppBarLayout</code>：<code>android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;</code>，</p>
<p><code>Toolbar</code>：<code>app:popupTheme=&quot;@style/AppTheme.PopupOverlay&quot;</code></p>
<p>Android 5.0引入一个全新的特性，允许你对view设置theme，这种设置会影响控件及其包含的子控件。这里对AppBarLayout的android:theme设置就有这种效果，而且系统目前只提供了两种默认的主题，Dark和Light,这里要说明的是android:theme如果设置的Dark主题，ToolBar的Title显示的是白色，如果设置的Light主题，Title是黑色，有点奇怪）</p>
<p>那有人在想，app:popupTheme又是干嘛的呢？问得好，这里的app:popupTheme是设置菜单的样式的，也有下面两种设置方式</p>
<ul>
<li>ThemeOverlay.AppCompat.Light</li>
</ul>
<p><img src="/images/popupOverlay_light.png" alt=""></p>
<ul>
<li>ThemeOverlay.AppCompat.Dark</li>
</ul>
<p><img src="/images/popupOverlay_dark.png" alt=""></p>
<hr>
<p>上面的说的一些基本情况，如果我们要定制一些特使的Toolbar呢，接下来介绍几种定制的情况</p>
<ol>
<li><p>Toolbar的背景</p>
<p> 直接在xml配置下Toolbar的背景就好了</p>
<pre><code>android:background=&quot;@color/window_background&quot;
</code></pre></li>
<li><p>Toolbar的高度</p>
<p> 系统默认取的是 </p>
<pre><code>android:layout_height=&quot;?attr/actionBarSize&quot;
</code></pre><p> 通过代码可以可知系统默认toolbar的告诉是<code>56dp</code>,很多app都觉得有点厚了，比如微信，网易，想把高度改小一点，比如48dp,该怎么改呢？直接定义Toolbar的告诉不就好了，</p>
<pre><code>android:layout_height=&quot;48dp&quot;
</code></pre><p> 效果是这样</p>
<p> <img src="/images/custom_toolbar_height.png" alt=""></p>
<p> 这里为了更直观的看到问题，我把返回按钮放出来了，发现问题了吧，返回键和menu键和title没有对齐，oh，no，这也太丑了，怎么解决呢，很简单，给toolbar加一句代码就好了</p>
<pre><code>android:minHeight=&quot;48dp&quot;
</code></pre><p> 搞定！</p>
<p> <img src="/images/custom_toolbar_height_48.png" alt=""></p>
</li>
<li><p>Toolbar title的颜色和大小</p>
<p> 其实这里我们Toolbar的背景不为白色的话，其实是不需要定制的，直接采用系统的Light主题就OK了，但是如果设计非要弄个白色，而我们又不喜欢Dark主题的纯黑字体，或者其他原因，那我们就只能自己定制了</p>
<p> 大家应该和我一样，第一想到的是跟定制ActionBar一样，在style文件里配置一下不就好了吗？就像这样</p>
<pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;
    &lt;!-- Customize your theme here. --&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name=&quot;android:titleTextStyle&quot;&gt;@style/ActionBar.TitleText&lt;/item&gt;
&lt;/style&gt;

&lt;style name=&quot;ActionBar.TitleText&quot; parent=&quot;android:TextAppearance.Holo.Widget.ActionBar.Title&quot;&gt;
    &lt;item name=&quot;android:textColor&quot;&gt;#FFFFFF&lt;/item&gt;
    &lt;item name=&quot;android:textSize&quot;&gt;12sp&lt;/item&gt;
&lt;/style&gt;
</code></pre><p> 事实是根本不起作用。。</p>
<p> 笔者尝试了很多种利用样式来改变的方式，都失败了，所以想了一种比较笨的方法，下面介绍一下，思路很简单，直接上代码</p>
<pre><code>&lt;android.support.v7.widget.Toolbar
    android:id=&quot;@+id/toolbar&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;48dp&quot;
    android:background=&quot;@color/window_background&quot;
    android:minHeight=&quot;48dp&quot;
    app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Dark&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/tv_title&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:ellipsize=&quot;end&quot;
        android:gravity=&quot;left|center_vertical&quot;
        android:singleLine=&quot;true&quot;
        android:textColor=&quot;@color/colorAccent&quot;
        android:textSize=&quot;28sp&quot;
        tools:text=&quot;更多&quot;/&gt;
&lt;/android.support.v7.widget.Toolbar&gt;
</code></pre><p> 通过在BaseActivity里对外提供title设置方法</p>
<pre><code>public void setTitle(String title) {
    mTitle.setText(title);
}    
</code></pre><p> 如果有些子标题，也可以在toolbar下定制，为了看看效果，此处把字体设大了些，如图</p>
<p> <img src="/images/toolbar_tm25.png" alt=""></p>
<p> 以上就是我对定制toolbar的一些见解，如果你有不同的思路，请给我留言，一起探讨更好的方法</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/31/2016-01-31-multi_thread_download/" itemprop="url">
                  android中利用多线程实现断点下载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-31T00:00:00+08:00" content="2016-01-31">
              2016-01-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/31/2016-01-31-multi_thread_download/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/31/2016-01-31-multi_thread_download/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>首先我们要下载的文件是比较大的，有一两百M,因为单线程下载会非常慢，用户肯定是没有耐心去等待的，体验也会大打折扣，所以我采取了多线程的下载方式，同时采用了线程池的方式来管理多线程。因为线程池可以限制系统中执行线程的数量，根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>使用线程池有三点好处</p>
<p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
<p>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
<p>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</p>
<p>java中主要用到的线程池有下面四种</p>
<ul>
<li><strong>newSingleThreadExecutor</strong><br>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
<li><strong>newFixedThreadPool</strong><br>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
<li><strong>newCachedThreadPool</strong><br>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，<br>那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li>
<li><strong>newScheduledThreadPool</strong><br>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<p><a href="http://www.infoq.com/cn/articles/java-threadPool/" target="_blank" rel="external">JAVA线程池的分析和使用</a></p>
<p><a href="http://www.oschina.net/question/565065_86540" target="_blank" rel="external">Java线程池使用说明</a></p>
<h2 id="多线程下载的原理"><a href="#多线程下载的原理" class="headerlink" title="多线程下载的原理"></a>多线程下载的原理</h2><p>1、在本地创建一个大小跟服务器文件相同大小的临时文件。</p>
<p>2、计算分配几个线程去下载服务器上的资源，知道每个线程下载文件的位置。</p>
<p>从上面的原理可以看出，多线程下载就是讲一个文件分成几段，然后每段分别开线程去下载，可是我们平时在访问一个文件时都是对整个文件进行读写，那怎样才能进行分段访问呢？那就要用到下面它<a href="http://developer.android.com/intl/zh-cn/reference/java/io/RandomAccessFile.html" target="_blank" rel="external">RandomAccessFile</a>了，它是一个随机文件访问类</p>
<p>我们在多线程断点下载的过程中，主要用到它的<code>seek</code>方法，</p>
<pre><code>void seek(long pos)

This method sets the file-pointer offset, measured from the beginning of this file, at which the next read or write occurs.
</code></pre><p>这个方法可以将文件的操作位置指向任何地方，其实所谓的<code>断点下载</code>就是利用的这点，让我们在下载过程中点击了暂停，我们记下此时文件已经下载的位置，当我们点继续下载的时候，我们只需拿到这个位置，然后调用<code>seek</code>方法，就可继续上次的下载了，而不用重新下载</p>
<p>最后贴两个写的比较好的两个开源库</p>
<p><a href="https://github.com/lingochamp/FileDownloader" target="_blank" rel="external">FileDownloader</a></p>
<p><a href="https://github.com/Aspsine/MultiThreadDownload" target="_blank" rel="external">MultiThreadDownload</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/29/2015-11-29-CoordinatorLayout/" itemprop="url">
                  CoordinatorLayout的使用场景
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-29T00:00:00+08:00" content="2015-11-29">
              2015-11-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/11/29/2015-11-29-CoordinatorLayout/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/11/29/2015-11-29-CoordinatorLayout/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          Android Design Support Library
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/11/29/2015-11-29-CoordinatorLayout/">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/07/2015-06-07-wheelview-highlight-current-item/" itemprop="url">
                  高亮显示滚轮控件WheelView选中项
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-06-07T00:00:00+08:00" content="2015-06-07">
              2015-06-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/06/07/2015-06-07-wheelview-highlight-current-item/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/07/2015-06-07-wheelview-highlight-current-item/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先看效果图</p>
<p><img src="/images/hightlight-wheel-current.png" alt="image"></p>
<p>本示例基于开源项目<a href="https://code.google.com/p/android-wheel/" target="_blank" rel="external">android-wheel</a>修改，这个项目已经开源很早，相信很多人也已用过了，最近项目需要将当前选中的item高亮显示，现将我采用的方法分享一下</p>
<p>我们显示的滚轮一般就两种类型（文字或者数字），对应的Adapter分别是<code>ArrayWheelAdapter</code>和<code>NumericWheelAdapter</code>，我们只需要重写这两个Adapter即可</p>
<p>文字类型:</p>
<pre><code>public class UnitArrayWheelAdapter extends ArrayWheelAdapter&lt;String&gt; {
    // Index of current item
    int currentItem;
    // Index of item to be highlighted
    int currentValue;

    /**
     * Constructor
     */
    public UnitArrayWheelAdapter(Context context, String[] items, int current) {
        super(context, items);
        this.currentValue = current;
    }

    @Override
    protected void configureTextView(TextView view) {
        super.configureTextView(view);
        if (currentItem == currentValue) {
            view.setTextColor(0xFFFF7500);
            view.setTextSize(18);
        }
        view.setTypeface(Typeface.SANS_SERIF);
    }

    @Override
    public View getItem(int index, View cachedView, ViewGroup parent) {
        currentItem = index;
        return super.getItem(index, cachedView, parent);
    }
}
</code></pre><p>数字类型:</p>
<pre><code>public class UnitNumericWheelAdapter extends NumericWheelAdapter {
    // Index of current item
    int currentItem;
    // Index of item to be highlighted
    int currentValue;

    /**
     * Constructor
     */
    public UnitNumericWheelAdapter(Context context, int minValue, int maxValue, int current) {
        super(context, minValue, maxValue);
        this.currentValue = current;
    }

    @Override
    protected void configureTextView(TextView view) {
        super.configureTextView(view);
        if (currentItem == currentValue) {
            view.setTextColor(0xFFFF7500);
            view.setTextSize(18);
        }
        view.setTypeface(Typeface.SANS_SERIF);

    }

    @Override
    public View getItem(int index, View cachedView, ViewGroup parent) {
        currentItem = index;
        return super.getItem(index, cachedView, parent);
    }
}
</code></pre><p>最后需要对wheelview添加滚动监听</p>
<pre><code>wheelview.addChangingListener(new OnWheelChangedListener() {
        @Override
        public void onChanged(WheelView wheel, int oldValue, int newValue) {
             wheel.setViewAdapter(new UnitArrayWheelAdapter(context, strings, current);//important
        }
    });
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/03/2015-05-03-webviewclient-chromeclient/" itemprop="url">
                  WebViewClient和WebChromeClient的区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-03T00:00:00+08:00" content="2015-05-03">
              2015-05-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/05/03/2015-05-03-webviewclient-chromeclient/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/03/2015-05-03-webviewclient-chromeclient/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="WebViewClient"><a href="#WebViewClient" class="headerlink" title="WebViewClient"></a>WebViewClient</h2><p>WebViewClient主要帮助WebView处理各种通知、请求事件等，比较常用的方法有</p>
<pre><code>public boolean shouldOverrideUrlLoading(WebView view, String url) 
</code></pre><p>这个方法有以下三种情况：</p>
<ol>
<li>若没有设置 WebViewClient 则在点击链接之后由系统处理该 url，通常是使用浏览器打开或弹出浏览器选择对话框。</li>
<li>若设置 WebViewClient 且该方法返回 true ，则说明由应用的代码处理该 url，WebView 不处理。薄荷现在很多自定义协议就属于这种情况</li>
<li>若设置 WebViewClient 且该方法返回 false，则说明由 WebView 处理该 url，即用 WebView 加载该 url。    </li>
</ol>
<hr>
<pre><code>public void onPageStarted(WebView view, String url, Bitmap favicon)  

public void onPageFinished(WebView view, String url) 
</code></pre><p>页面开始与结束的监听方法</p>
<hr>
<pre><code>public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) 
</code></pre><p>通常我们通过webview来访问web页面都是在网络的情况下，一旦没有网络就会显示”无法找到该网页”的信息，这样会暴露我们的连接，如下图</p>
<p><img src="/images/webview-error.png" alt="webview-error"></p>
<p>所以我们需要一个有好的提示，并且不会暴露链接的方法。这时候WebViewClient的onReceivedError方法就派上了用场了，我们需要在本地自定义一个错误页面，然后加载即可</p>
<h2 id="WebChromeClient"><a href="#WebChromeClient" class="headerlink" title="WebChromeClient"></a>WebChromeClient</h2><p>WebChromeClient主要辅助WebView处理Javascript的对话框、网站图标、网站title、加载进度等,常用的方法有</p>
<pre><code>@Override
public void onProgressChanged(WebView view, int newProgress) {
    super.onProgressChanged(view, newProgress);
    getActivity().setProgress(newProgress);
}
</code></pre><p>监视加载进度，如果我们想在布局顶部显示一个进度条，我们可以直接在上面方法中调用 <code>getActivity().setProgress(newProgress);</code>，而不需要在顶部加个progressBar了</p>
<hr>
<pre><code>public boolean onJsAlert(WebView view, String url, String message, JsResult result) 
</code></pre><p>监测javascript的alert()弹出，类似的还有onJsPrompt，onJsConfirm</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/26/2015-04-26-recycleview-cardview/" itemprop="url">
                  RecyclerView、CardView
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-26T00:00:00+08:00" content="2015-04-26">
              2015-04-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/26/2015-04-26-recycleview-cardview/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/26/2015-04-26-recycleview-cardview/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android L的support library中包含了两个新的组件（<strong>RecyclerView</strong>和<strong>CardView</strong>），他们可以用于显示复杂的布局而且都默认采用了Material的风格。</p>
<h2 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h2><p>很多人将它跟ListView对比，说它升级版的ListView,其实它可以做的更多，比如GridView也可以用它来代替，还比如listView中item的样式有多种，也可以通过它来实现，拓展性很强，这里只是简单介绍下它们的使用方法，就以薄荷的收货地址为例，没用RecyclerView的样子如下图：</p>
<p><img src="/images/recyclerview-cardview-1.png" alt="recyclerview-cardview1"></p>
<p>使用起来很简单</p>
<ol>
<li><p>添加依赖</p>
<pre><code>compile &apos;com.android.support:recyclerview-v7:21.0.3&apos;
compile &apos;com.android.support:cardview-v7:21.0.3&apos;
</code></pre></li>
<li><p>添加xml文件</p>
<pre><code>&lt;android.support.v7.widget.RecyclerView
  android:id=&quot;@+id/recycler_view&quot;
  android:layout_width=&quot;match_parent&quot;
  android:layout_height=&quot;match_parent&quot; /&gt;
</code></pre></li>
<li><p>初始化（跟listview不同）</p>
<pre><code> recycler_view = (RecyclerView) findViewById(id.recycler_view);
//设置LinearLayoutManager  可以指定方向，默认是垂直， 可以设置成水平。
mLayoutManager = new LinearLayoutManager(this);
//mLayoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);
recycler_view.setLayoutManager(mLayoutManager);
//设置adapter 
addressListAdapter = new AddressListAdapter(ctx, mAddressList);
recycler_view.setAdapter(addressListAdapter);
</code></pre></li>
</ol>
<p>这里和listview对比最大的不同就是Adapter了，它必须继承自<code>RecyclerView.Adapter</code>，源码如下：</p>
<pre><code>public class AddressListAdapter extends RecyclerView.Adapter&lt;AddressListAdapter.ViewHolder&gt; {
static final String TAG = AddressListAdapter.class.getName();
public onAddressUpdateListener addressUpdateListener;

private Context mContext;
private List&lt;Address&gt; mAddresses;

public AddressListAdapter(Context mContext, List&lt;Address&gt; addresses) {
    super();
    this.mContext = mContext;
    this.mAddresses = addresses;
}

public static class ViewHolder extends RecyclerView.ViewHolder {
    public TextView txt_real_name;

    public ViewHolder(View v) {
        super(v);
        txt_real_name = (TextView) v.findViewById(R.id.txt_real_name);

    }
}

@Override
public int getItemCount() {
    return mAddresses.size();
}


@Override
public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.uchoice_address_list_item, parent, false);
    return new ViewHolder(v);
}

@Override
public void onBindViewHolder(final ViewHolder holder, final int position) {
    final Address address = mAddresses.get(position);
    holder.txt_real_name.setText(address.real_name);
}

}//为了看起来直观只贴了部分代码
</code></pre><p>RecyclerView标准化了ViewHolder，ListView中convertView是复用的，在RecyclerView中，是把ViewHolder作为缓存的单位了，然后convertView作为ViewHolder的成员变量保持在ViewHolder中,<code>onCreateViewHolder()</code>专门用来生成    ViewHolder，<code>onBindViewHolder()</code>用来加载数据，分工很明确，比之前所有的逻辑都放在getView()要清晰很多，以上就是RecyclerView的简单用法了</p>
<h2 id="ItemAnimator"><a href="#ItemAnimator" class="headerlink" title="ItemAnimator"></a>ItemAnimator</h2><p>ItemAnimator也是一个抽象类，系统为我们提供了一种默认的实现类（<code>DefaultItemAnimator</code>），添加的方法也很简单：</p>
<pre><code>// 设置item动画
recycler_view.setItemAnimator(new DefaultItemAnimator());
</code></pre><p>如果我们想实现更多的动画效果呢？别急，已经有人写好很多了，请看：<a href="https://github.com/gabrielemariotti/RecyclerViewItemAnimators" target="_blank" rel="external">RecyclerViewItemAnimators</a></p>
<h2 id="CardView"><a href="#CardView" class="headerlink" title="CardView"></a>CardView</h2><p>CardView继承自FrameLayout类，可以在一个卡片布局中一致性的显示内容，使用方法跟FrameLayout一样，卡片可以包含<strong>圆角和阴影</strong>。我们可以使用</p>
<ul>
<li><p>android:cardCornerRadius属性指定圆角半径</p>
</li>
<li><p>android:cardBackgroundColor属性设置卡片颜色</p>
</li>
<li><p>android:elevation：设置阴影的大小</p>
</li>
</ul>
<p>最后效果如下：</p>
<p><img src="/images/recyclerview-cardview.png" alt="recyclerview-cardview"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/16/2015-04-16-http缓存/" itemprop="url">
                  HTTP缓存机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-16T00:00:00+08:00" content="2015-04-16">
              2015-04-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index">
                    <span itemprop="name">http</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/16/2015-04-16-http缓存/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/16/2015-04-16-http缓存/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于http缓存"><a href="#关于http缓存" class="headerlink" title="关于http缓存"></a>关于http缓存</h2><p>有很多解释，大体都相似，其实就是当Web请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是从原始服务器中提取这个文档。缓存有很多的好处</p>
<ol>
<li><p>减少了冗余的数据传输，节省了网费。</p>
</li>
<li><p>减少了服务器的负担， 大大提高了网站的性能</p>
</li>
<li><p>加快了客户端加载网页的速度</p>
</li>
</ol>
<h2 id="如何判断缓存新鲜度"><a href="#如何判断缓存新鲜度" class="headerlink" title="如何判断缓存新鲜度"></a>如何判断缓存新鲜度</h2><p>Web服务器通过2种方式来判断浏览器缓存是否是最新的。</p>
<ol>
<li><p>浏览器把缓存文件的最后修改时间Last-Modified 通过 header ”If-Modified-Since“来告诉Web服务器。</p>
</li>
<li><p>浏览器把缓存文件的ETag, 通过header “If-None-Match”, 来告诉Web服务器。</p>
</li>
</ol>
<p><strong>Last-Modified/If-Modified-Since</strong></p>
<p>Last-Modified/If-Modified-Since要配合Cache-Control使用。</p>
<p><strong>Last-Modified</strong>：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。</p>
<p><strong>If-Modified-Since</strong>：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</p>
<p><strong>Etag/If-None-Match</strong></p>
<p>Etag/If-None-Match也要配合Cache-Control使用。</p>
<p><strong>Etag</strong>：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）。Apache中，<strong><em>ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</em></strong></p>
<p><strong>If-None-Match</strong>：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。</p>
<h2 id="为什么使用ETag呢？"><a href="#为什么使用ETag呢？" class="headerlink" title="为什么使用ETag呢？"></a>为什么使用ETag呢？</h2><p>主要是为了解决Last-Modified 无法解决的一些问题。</p>
<ol>
<li><p>某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。</p>
</li>
<li><p>某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。</p>
</li>
<li><p>一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了。</p>
</li>
</ol>
<h2 id="与缓存有关的header"><a href="#与缓存有关的header" class="headerlink" title="与缓存有关的header"></a>与缓存有关的header</h2><ul>
<li><p><strong>request</strong></p>
<ul>
<li>Cache-Control: max-age=0    以秒为单位</li>
<li>If-Modified-Since: Mon, 19 Nov 2012 08:38:01 GMT 缓存文件的最后修改时间。</li>
<li>If-None-Match: “0693f67a67cc1:0”    缓存文件的Etag值</li>
<li>Cache-Control: no-cache    不使用缓存</li>
<li>Pragma: no-cache    不使用缓存</li>
</ul>
</li>
<li><p><strong>response</strong></p>
<ul>
<li>Cache-Control: public        响应被缓存，并且在多用户间共享</li>
<li>Cache-Control: private    响应只能作为私有缓存，不能在用户之间共享</li>
<li>Cache-Control:no-cache    提醒浏览器要从服务器提取文档进行验证</li>
<li>Cache-Control:no-store    绝对禁止缓存（用于机密，敏感文件）</li>
<li>Cache-Control: max-age=60         60秒之后缓存过期（相对时间）</li>
<li>Date: Mon, 19 Nov 2012 08:39:00 GMT    当前response发送的时间</li>
<li>Expires: Mon, 19 Nov 2012 08:40:01 GMT    缓存过期的时间（绝对时间）</li>
<li>Last-Modified: Mon, 19 Nov 2012 08:38:01 GMT 服务器端文件的最后修改时间</li>
<li>ETag: “20b1add7ec1cd1:0”    服务器端文件的Etag值</li>
</ul>
</li>
</ul>
<p>下面是一张http缓存流程图，画的非常简洁易懂</p>
<p><img src="/images/http-cache.png" alt="http-cache"></p>
<p>参考：</p>
<p><a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="external">浏览器缓存机制</a>    </p>
<p><a href="http://www.cnblogs.com/tankxiao/archive/2012/11/28/2793365.html" target="_blank" rel="external">HTTP协议 (四) 缓存</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/loofee.png"
               alt="loody" />
          <p class="site-author-name" itemprop="name">loody</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">32</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">42</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/loody" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2396231120/profile?topnav=1&wvr=6&is_all=1" target="_blank">
                  
                    <i class="fa fa-globe"></i> weibo
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">loody</span>
</div>

<div class="powered-by">
  <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"loody"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  


</body>
</html>
