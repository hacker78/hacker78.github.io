<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="loody's blog">
<meta property="og:url" content="http://loody.github.io/page/2/index.html">
<meta property="og:site_name" content="loody's blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="loody's blog">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> loody's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?f99c8e8fc92fd70fbf50a1494cf47607";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">loody's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/03/2015-05-03-webviewclient-chromeclient/" itemprop="url">
                  WebViewClient和WebChromeClient的区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-03T00:00:00+08:00" content="2015-05-03">
              2015-05-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/05/03/2015-05-03-webviewclient-chromeclient/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/03/2015-05-03-webviewclient-chromeclient/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="WebViewClient"><a href="#WebViewClient" class="headerlink" title="WebViewClient"></a>WebViewClient</h2><p>WebViewClient主要帮助WebView处理各种通知、请求事件等，比较常用的方法有</p>
<pre><code>public boolean shouldOverrideUrlLoading(WebView view, String url) 
</code></pre><p>这个方法有以下三种情况：</p>
<ol>
<li>若没有设置 WebViewClient 则在点击链接之后由系统处理该 url，通常是使用浏览器打开或弹出浏览器选择对话框。</li>
<li>若设置 WebViewClient 且该方法返回 true ，则说明由应用的代码处理该 url，WebView 不处理。薄荷现在很多自定义协议就属于这种情况</li>
<li>若设置 WebViewClient 且该方法返回 false，则说明由 WebView 处理该 url，即用 WebView 加载该 url。    </li>
</ol>
<hr>
<pre><code>public void onPageStarted(WebView view, String url, Bitmap favicon)  

public void onPageFinished(WebView view, String url) 
</code></pre><p>页面开始与结束的监听方法</p>
<hr>
<pre><code>public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) 
</code></pre><p>通常我们通过webview来访问web页面都是在网络的情况下，一旦没有网络就会显示”无法找到该网页”的信息，这样会暴露我们的连接，如下图</p>
<p><img src="/images/webview-error.png" alt="webview-error"></p>
<p>所以我们需要一个有好的提示，并且不会暴露链接的方法。这时候WebViewClient的onReceivedError方法就派上了用场了，我们需要在本地自定义一个错误页面，然后加载即可</p>
<h2 id="WebChromeClient"><a href="#WebChromeClient" class="headerlink" title="WebChromeClient"></a>WebChromeClient</h2><p>WebChromeClient主要辅助WebView处理Javascript的对话框、网站图标、网站title、加载进度等,常用的方法有</p>
<pre><code>@Override
public void onProgressChanged(WebView view, int newProgress) {
    super.onProgressChanged(view, newProgress);
    getActivity().setProgress(newProgress);
}
</code></pre><p>监视加载进度，如果我们想在布局顶部显示一个进度条，我们可以直接在上面方法中调用 <code>getActivity().setProgress(newProgress);</code>，而不需要在顶部加个progressBar了</p>
<hr>
<pre><code>public boolean onJsAlert(WebView view, String url, String message, JsResult result) 
</code></pre><p>监测javascript的alert()弹出，类似的还有onJsPrompt，onJsConfirm</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/26/2015-04-26-recycleview-cardview/" itemprop="url">
                  RecyclerView、CardView
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-26T00:00:00+08:00" content="2015-04-26">
              2015-04-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/26/2015-04-26-recycleview-cardview/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/26/2015-04-26-recycleview-cardview/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android L的support library中包含了两个新的组件（<strong>RecyclerView</strong>和<strong>CardView</strong>），他们可以用于显示复杂的布局而且都默认采用了Material的风格。</p>
<h2 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h2><p>很多人将它跟ListView对比，说它升级版的ListView,其实它可以做的更多，比如GridView也可以用它来代替，还比如listView中item的样式有多种，也可以通过它来实现，拓展性很强，这里只是简单介绍下它们的使用方法，就以薄荷的收货地址为例，没用RecyclerView的样子如下图：</p>
<p><img src="/images/recyclerview-cardview-1.png" alt="recyclerview-cardview1"></p>
<p>使用起来很简单</p>
<ol>
<li><p>添加依赖</p>
<pre><code>compile &apos;com.android.support:recyclerview-v7:21.0.3&apos;
compile &apos;com.android.support:cardview-v7:21.0.3&apos;
</code></pre></li>
<li><p>添加xml文件</p>
<pre><code>&lt;android.support.v7.widget.RecyclerView
  android:id=&quot;@+id/recycler_view&quot;
  android:layout_width=&quot;match_parent&quot;
  android:layout_height=&quot;match_parent&quot; /&gt;
</code></pre></li>
<li><p>初始化（跟listview不同）</p>
<pre><code> recycler_view = (RecyclerView) findViewById(id.recycler_view);
//设置LinearLayoutManager  可以指定方向，默认是垂直， 可以设置成水平。
mLayoutManager = new LinearLayoutManager(this);
//mLayoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);
recycler_view.setLayoutManager(mLayoutManager);
//设置adapter 
addressListAdapter = new AddressListAdapter(ctx, mAddressList);
recycler_view.setAdapter(addressListAdapter);
</code></pre></li>
</ol>
<p>这里和listview对比最大的不同就是Adapter了，它必须继承自<code>RecyclerView.Adapter</code>，源码如下：</p>
<pre><code>public class AddressListAdapter extends RecyclerView.Adapter&lt;AddressListAdapter.ViewHolder&gt; {
static final String TAG = AddressListAdapter.class.getName();
public onAddressUpdateListener addressUpdateListener;

private Context mContext;
private List&lt;Address&gt; mAddresses;

public AddressListAdapter(Context mContext, List&lt;Address&gt; addresses) {
    super();
    this.mContext = mContext;
    this.mAddresses = addresses;
}

public static class ViewHolder extends RecyclerView.ViewHolder {
    public TextView txt_real_name;

    public ViewHolder(View v) {
        super(v);
        txt_real_name = (TextView) v.findViewById(R.id.txt_real_name);

    }
}

@Override
public int getItemCount() {
    return mAddresses.size();
}


@Override
public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.uchoice_address_list_item, parent, false);
    return new ViewHolder(v);
}

@Override
public void onBindViewHolder(final ViewHolder holder, final int position) {
    final Address address = mAddresses.get(position);
    holder.txt_real_name.setText(address.real_name);
}

}//为了看起来直观只贴了部分代码
</code></pre><p>RecyclerView标准化了ViewHolder，ListView中convertView是复用的，在RecyclerView中，是把ViewHolder作为缓存的单位了，然后convertView作为ViewHolder的成员变量保持在ViewHolder中,<code>onCreateViewHolder()</code>专门用来生成    ViewHolder，<code>onBindViewHolder()</code>用来加载数据，分工很明确，比之前所有的逻辑都放在getView()要清晰很多，以上就是RecyclerView的简单用法了</p>
<h2 id="ItemAnimator"><a href="#ItemAnimator" class="headerlink" title="ItemAnimator"></a>ItemAnimator</h2><p>ItemAnimator也是一个抽象类，系统为我们提供了一种默认的实现类（<code>DefaultItemAnimator</code>），添加的方法也很简单：</p>
<pre><code>// 设置item动画
recycler_view.setItemAnimator(new DefaultItemAnimator());
</code></pre><p>如果我们想实现更多的动画效果呢？别急，已经有人写好很多了，请看：<a href="https://github.com/gabrielemariotti/RecyclerViewItemAnimators" target="_blank" rel="external">RecyclerViewItemAnimators</a></p>
<h2 id="CardView"><a href="#CardView" class="headerlink" title="CardView"></a>CardView</h2><p>CardView继承自FrameLayout类，可以在一个卡片布局中一致性的显示内容，使用方法跟FrameLayout一样，卡片可以包含<strong>圆角和阴影</strong>。我们可以使用</p>
<ul>
<li><p>android:cardCornerRadius属性指定圆角半径</p>
</li>
<li><p>android:cardBackgroundColor属性设置卡片颜色</p>
</li>
<li><p>android:elevation：设置阴影的大小</p>
</li>
</ul>
<p>最后效果如下：</p>
<p><img src="/images/recyclerview-cardview.png" alt="recyclerview-cardview"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/16/2015-04-16-http缓存/" itemprop="url">
                  HTTP缓存机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-16T00:00:00+08:00" content="2015-04-16">
              2015-04-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index">
                    <span itemprop="name">http</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/16/2015-04-16-http缓存/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/16/2015-04-16-http缓存/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于http缓存"><a href="#关于http缓存" class="headerlink" title="关于http缓存"></a>关于http缓存</h2><p>有很多解释，大体都相似，其实就是当Web请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是从原始服务器中提取这个文档。缓存有很多的好处</p>
<ol>
<li><p>减少了冗余的数据传输，节省了网费。</p>
</li>
<li><p>减少了服务器的负担， 大大提高了网站的性能</p>
</li>
<li><p>加快了客户端加载网页的速度</p>
</li>
</ol>
<h2 id="如何判断缓存新鲜度"><a href="#如何判断缓存新鲜度" class="headerlink" title="如何判断缓存新鲜度"></a>如何判断缓存新鲜度</h2><p>Web服务器通过2种方式来判断浏览器缓存是否是最新的。</p>
<ol>
<li><p>浏览器把缓存文件的最后修改时间Last-Modified 通过 header ”If-Modified-Since“来告诉Web服务器。</p>
</li>
<li><p>浏览器把缓存文件的ETag, 通过header “If-None-Match”, 来告诉Web服务器。</p>
</li>
</ol>
<p><strong>Last-Modified/If-Modified-Since</strong></p>
<p>Last-Modified/If-Modified-Since要配合Cache-Control使用。</p>
<p><strong>Last-Modified</strong>：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。</p>
<p><strong>If-Modified-Since</strong>：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</p>
<p><strong>Etag/If-None-Match</strong></p>
<p>Etag/If-None-Match也要配合Cache-Control使用。</p>
<p><strong>Etag</strong>：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）。Apache中，<strong><em>ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</em></strong></p>
<p><strong>If-None-Match</strong>：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。</p>
<h2 id="为什么使用ETag呢？"><a href="#为什么使用ETag呢？" class="headerlink" title="为什么使用ETag呢？"></a>为什么使用ETag呢？</h2><p>主要是为了解决Last-Modified 无法解决的一些问题。</p>
<ol>
<li><p>某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。</p>
</li>
<li><p>某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。</p>
</li>
<li><p>一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了。</p>
</li>
</ol>
<h2 id="与缓存有关的header"><a href="#与缓存有关的header" class="headerlink" title="与缓存有关的header"></a>与缓存有关的header</h2><ul>
<li><p><strong>request</strong></p>
<ul>
<li>Cache-Control: max-age=0    以秒为单位</li>
<li>If-Modified-Since: Mon, 19 Nov 2012 08:38:01 GMT 缓存文件的最后修改时间。</li>
<li>If-None-Match: “0693f67a67cc1:0”    缓存文件的Etag值</li>
<li>Cache-Control: no-cache    不使用缓存</li>
<li>Pragma: no-cache    不使用缓存</li>
</ul>
</li>
<li><p><strong>response</strong></p>
<ul>
<li>Cache-Control: public        响应被缓存，并且在多用户间共享</li>
<li>Cache-Control: private    响应只能作为私有缓存，不能在用户之间共享</li>
<li>Cache-Control:no-cache    提醒浏览器要从服务器提取文档进行验证</li>
<li>Cache-Control:no-store    绝对禁止缓存（用于机密，敏感文件）</li>
<li>Cache-Control: max-age=60         60秒之后缓存过期（相对时间）</li>
<li>Date: Mon, 19 Nov 2012 08:39:00 GMT    当前response发送的时间</li>
<li>Expires: Mon, 19 Nov 2012 08:40:01 GMT    缓存过期的时间（绝对时间）</li>
<li>Last-Modified: Mon, 19 Nov 2012 08:38:01 GMT 服务器端文件的最后修改时间</li>
<li>ETag: “20b1add7ec1cd1:0”    服务器端文件的Etag值</li>
</ul>
</li>
</ul>
<p>下面是一张http缓存流程图，画的非常简洁易懂</p>
<p><img src="/images/http-cache.png" alt="http-cache"></p>
<p>参考：</p>
<p><a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="external">浏览器缓存机制</a>    </p>
<p><a href="http://www.cnblogs.com/tankxiao/archive/2012/11/28/2793365.html" target="_blank" rel="external">HTTP协议 (四) 缓存</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/11/2015-04-11-viewpager-head-scroll/" itemprop="url">
                  实现滚动隐藏header的layout
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-11T00:00:00+08:00" content="2015-04-11">
              2015-04-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/11/2015-04-11-viewpager-head-scroll/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/11/2015-04-11-viewpager-head-scroll/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近薄荷新版加入了圈子的功能，圈子主页效果图如下：</p>
<p><img src="/images/club.jpg" alt="image"></p>
<p>往上滑可以隐藏header,将4个tab停留在顶部，往下滑又可以展开header,其中tab里的内容还可以实现下拉刷新，上拉加载更多</p>
<p>第一个想到的是外面包一层<strong><a href="https://github.com/emilsjolander/StickyScrollViewItems" target="_blank" rel="external">StickyScrollViewItems</a></strong>，可以很快的实现tab的悬浮，但是刷新的操作就必须放在外面了，于是又外面套了层swiperefreshlayout实现刷新，由于下面的tab有两个需要刷新，所以处理起来非常麻烦的，再加上scrollview+viewpager+listview的嵌套会出现各种冲突，所以这种思路从一开始就是个错误。于是想想有没有能实现滚动隐藏header的layout的呢？于是上github一搜，果然有类似效果的开源项目，那就是接下来要介绍的<strong><a href="https://github.com/ongakuer/ViewPagerHeaderScrollDemo" target="_blank" rel="external">ViewPagerHeaderScrollDemo</a></strong></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>通过自定义<code>TouchCallbackLayout</code>，这个类继承自FrameLayout,在里边放置一个ViewPager和一个header+tab的layout,给ViewPager设定一个marginTop的高度，这个高度也就是tab栏的高度，通过计算ViewPager中fragment的滑动来控制header的现实与隐藏</p>
<p>fragment是怎么控制header的显示与隐藏的呢？总不能只要上滑就就隐藏，下滑就显示吧，这样如果fragment是一个很长的列表，当我滑到中间，再往下滑，这个时候我并不想看到header,我想看完列表中间以上的部分后再看到header怎么办？</p>
<p>这里定义一个接口</p>
<pre><code>public interface ScrollableListener {
    //判断其是否可以显示header
    public boolean isViewBeingDragged(MotionEvent event);
}
</code></pre><p>所有的fragment都要实现这个接口,作者已经实现fragment是如下两个类型的判断,ListView(AbsListViewDelegate)和ScrollView(ScrollViewDelegate)，基本已经满足大部分需求了，如果是WebView，可以在外面套一层ScrollView实现判断</p>
<h2 id="Scrollable"><a href="#Scrollable" class="headerlink" title="Scrollable"></a>Scrollable</h2><p>就在不久前，github又有一个可以实现类似效果的开源库：<a href="https://github.com/noties/Scrollable" target="_blank" rel="external">Scrollable</a>，大概看了下它的源码，实现思路跟上面介绍的很相似，只是在代码层面，Scrollable封装的更好些，作者也提供了gradle依赖，使用起来更方便！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/06/2015-04-06-view-TouchEvent/" itemprop="url">
                  View的事件传递
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-06T00:00:00+08:00" content="2015-04-06">
              2015-04-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/06/2015-04-06-view-TouchEvent/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/06/2015-04-06-view-TouchEvent/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一直对view之间的手势事件传递机制模模糊糊，今天来好好理理，首先说说一些关于事件的一些基础知识</p>
<h2 id="事件类型MotionEvent"><a href="#事件类型MotionEvent" class="headerlink" title="事件类型MotionEvent"></a>事件类型MotionEvent</h2><p><strong>ACTION_DOWN, ACTION_UP, ACTION_MOVE, ACTION_POINTER_DOWN, ACTION_POINTER_UP, ACTION_CANCEL</strong>等等，并且每个事件都是以<strong>ACTION_DOWN</strong>开始<strong>ACTION_UP</strong>结束的</p>
<h2 id="事件处理分类"><a href="#事件处理分类" class="headerlink" title="事件处理分类"></a>事件处理分类</h2><ol>
<li><p>事件分发</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent ev)
</code></pre><p> 只要你触摸了任何控件，就一定会调用该控件的dispatchTouchEvent方法</p>
</li>
<li><p>事件拦截</p>
<pre><code>public boolean onInterceptTouchEvent(MotionEvent ev)
</code></pre><p> 只有ViewGroup才有onInterceptTouchEvent方法，因为一个普通的View肯定是位于最深层的View，touch事件能够传到这里已经是最后一站了</p>
</li>
<li><p>事件响应</p>
<pre><code>public boolean onTouchEvent(MotionEvent ev)
</code></pre></li>
</ol>
<h2 id="事件传递流程"><a href="#事件传递流程" class="headerlink" title="事件传递流程"></a>事件传递流程</h2><p>(1) 事件从Activity.dispatchTouchEvent()开始传递，只要没有被停止或拦截，从最上层的View(ViewGroup)开始一直往下(子View)传递。子View可以通过onTouchEvent()对事件进行处理。</p>
<p>(2) 事件由父View(ViewGroup)传递给子View，ViewGroup可以通过onInterceptTouchEvent()对事件做拦截，停止其往下传递。</p>
<p>(3) 如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent()函数。        </p>
<h2 id="事件的层级传递"><a href="#事件的层级传递" class="headerlink" title="事件的层级传递"></a>事件的层级传递</h2><p>我们都知道如果给一个控件注册了touch事件，每次点击它的时候都会触发一系列的ACTION_DOWN，ACTION_MOVE，ACTION_UP等事件。这里需要注意，如果你在执行ACTION_DOWN的时候返回了false，后面一系列其它的action就不会再得到执行了。简单的说，就是当dispatchTouchEvent在进行事件分发的时候，只有前一个action返回true，才会触发后一个action。</p>
<h2 id="底层的View如何阻止父层的View截获touch事件"><a href="#底层的View如何阻止父层的View截获touch事件" class="headerlink" title="底层的View如何阻止父层的View截获touch事件"></a>底层的View如何阻止父层的View截获touch事件</h2><p>方法一：重写底层view的dispatchTouchEvent方法</p>
<pre><code>@Override    
public boolean dispatchTouchEvent(MotionEvent ev) {   
    getParent().requestDisallowInterceptTouchEvent(true);  
    return super.dispatchTouchEvent(ev);    
}  
</code></pre><p>方法二：当用户按下的时候，我们告诉父组件，不要拦截我的事件（这个时候子组件是可以正常响应事件的），拿起之后就会告诉父组件可以阻止。</p>
<pre><code>public boolean onTouch(View v, MotionEvent event) {
     switch (event.getAction()) {
         case MotionEvent.ACTION_MOVE: 
             myView.requestDisallowInterceptTouchEvent(true);
         break;
         case MotionEvent.ACTION_UP:
         case MotionEvent.ACTION_CANCEL:
             myView.requestDisallowInterceptTouchEvent(false);
         break;
     }
}
</code></pre><p>最后在网上找了两张流程图，觉得表达的很好，也一起分享一下：</p>
<ol>
<li><p>View不处理事件流程图</p>
<p> <img src="/images/view-touch-1.jpg" alt="view-touch-1"></p>
</li>
<li><p>View处理事件流程图</p>
<p> <img src="/images/view-touch-2.jpg" alt="view-touch-2"></p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/08/2015-03-08-hellocharts/" itemprop="url">
                  hellocharts与MPAndroidChart的比较
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-08T00:00:00+08:00" content="2015-03-08">
              2015-03-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/03/08/2015-03-08-hellocharts/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/03/08/2015-03-08-hellocharts/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记得之前介绍过关于MPAndroidChart的使用方法，但是长江后浪推前浪，最近github有出了一个新的开源曲线库，hellocharts,个人觉得这个库比MPAndroidChart更加酷炫，下面就介绍下它的一些使用方法</p>
<p>github地址：<a href="https://github.com/lecho/hellocharts-android" target="_blank" rel="external">https://github.com/lecho/hellocharts-android</a></p>
<h2 id="使用方法（同样以曲线为例，其他类似）"><a href="#使用方法（同样以曲线为例，其他类似）" class="headerlink" title="使用方法（同样以曲线为例，其他类似）"></a>使用方法（同样以曲线为例，其他类似）</h2><ul>
<li><p>xml</p>
<pre><code>&lt;lecho.lib.hellocharts.view.LineChartView 
    android:id=&quot;@+id/linechart&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;/&gt;
</code></pre></li>
<li><p>code</p>
<pre><code>LineChartView chart = new LineChartView(context);
layout.addView(chart);
</code></pre></li>
<li><p>data    </p>
<pre><code>List&lt;PointValue&gt; values = new ArrayList&lt;PointValue&gt;();
values.add(new PointValue(x,y));
...

   Line line = new Line(values);
List&lt;Line&gt; lines = new ArrayList&lt;Line&gt;();
lines.add(line);//可以有多条曲线

LineChartData data = new LineChartData();
data.setLines(lines);

chart.setLineChartData(data);
</code></pre></li>
</ul>
<h2 id="hellocharts和MPAndroidChart的比较"><a href="#hellocharts和MPAndroidChart的比较" class="headerlink" title="hellocharts和MPAndroidChart的比较"></a>hellocharts和MPAndroidChart的比较</h2><h2 id="曲线的样式"><a href="#曲线的样式" class="headerlink" title="曲线的样式"></a>曲线的样式</h2><p>在这一点上，MPAndroidChart比hellocharts要好，MPAndroidChart对曲线的样式非常的详细，包括曲线的颜色，粗细、样式（实线、虚线），曲线上点的颜色、粗细、形状，选中的点的图例（类似地图的标注，还可以自定义布局样式）、单位，整个图标的图例（每条曲线的颜色，标题等信息），曲线的上下限标识，x轴，Y轴的字体颜色，大小，字体样式等</p>
<p>特别说明：</p>
<ol>
<li><p>hellocharts在曲线的颜色，点的颜色，还有点的背景颜色默认是保持一致的，没法配置，这个比较伤脑筋，</p>
</li>
<li><p>MPAndroidChart不能在<code>set.setCubic(true)</code>模式下支持自定义<code>setFillColor()</code>;</p>
<p> 如果说对这些要求比较高的就要慎重选择了</p>
</li>
</ol>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>MPAndroidChart更方便一点，它支持三种动画</p>
<pre><code>animateX(int durationMillis):
 animateY(int durationMillis):
  animateXY(int xDuration, int yDuration): 
</code></pre><p>hellocharts也可以自定义动画的</p>
<pre><code>chartTop.setAnimation();
</code></pre><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>hellocharts更加灵活，它可以设置图标的缩放方向，而MPAndroidChart不能单独指定</p>
<pre><code>chartTop.setZoomType(ZoomType.HORIZONTAL);
//ZoomType:HORIZONTAL、VERTICAL、HORIZONTAL_AND_VERTICAL
</code></pre><h2 id="分页展示与滑动"><a href="#分页展示与滑动" class="headerlink" title="分页展示与滑动"></a>分页展示与滑动</h2><p>两个库在这个方面的表现差异很大，hellocharts的体验优势很大，下面我们详细说说这个</p>
<ol>
<li><p>单屏</p>
<p> MPAndroidChart默认是将所有的点都展示在一个屏幕上，这样一来，点少还可以，一旦点特别多的时候，展示就很难看，根本看不清楚点的x,y值，必须手动去缩放才能看清，很麻烦，图标展示就没有了意义.有人说，是不是可以通过通过设置曲线默认的缩放比例<code>mChart.setScaleMinima();</code>来达到分页展示的目的，事实上是可以的，但是效果很不好，很容易又恢复单屏显示</p>
</li>
<li><p>滑动不流畅</p>
<p>  MPAndroidChart的滑动是没有惯性的，只能手指贴面滑，体验很不好</p>
<p>有时候要展示的数据比较多，以上两个限制对用户的体验式致命的，还好，hellocharts解决了这两个问题，怎么解决的呢？</p>
<p>在hellocharts中引入了一个Viewport的东西，作者的解释是：<br>**The viewport is represented by the coordinates of its 4 edges (left, top, right</p>
<ul>
<li>bottom). These fields can be accessed directly. Use width() and height() to retrieve the viewport’s width and height.**</li>
</ul>
<p>我的理解，Viewport就是一个视图的概念，这个视图有上下左右四个边，好比一张全国地图，我们只想看某个省份的地图，所以我们只需要拿到某个省份的上下左右边界，然后展示出来就可以了，他就是全国地图中的一个子集</p>
<p>  public Viewport(float left, float top, float right, float bottom) </p>
<p>hellocharts有两个方法</p>
<p>  chartTop.setMaximumViewport(Viewport maxViewport)//所有的视图<br> chartTop.setCurrentViewport(Viewport targetViewport);//当前要展示的视图</p>
</li>
</ol>
<p>我们需要拿到左右数据的最大视图范围和当前要展示的视图范围，调用上面两个方法，即可完成数据的分页展示，关键是这个曲线库的滑动非常流程，体验非常赞</p>
<p>综上，如果大家要展示的数据比较少，对曲线样式，动画要求很高的可以选择MPAndroidChart，反之就选择hellocharts吧，当然具体情况还得自己斟酌，</p>
<p>ps:两个库的作者对项目维护活跃的都很高，MPAndroidChart最近也提供了gradle依赖，使用android studio的同学用起来更方便了    ，具体更新请随时关注github.</p>
<p>hellocharts：<a href="https://github.com/lecho/hellocharts-android" target="_blank" rel="external">https://github.com/lecho/hellocharts-android</a></p>
<p>MPAndroidChart：<a href="https://github.com/PhilJay/MPAndroidChart" target="_blank" rel="external">https://github.com/PhilJay/MPAndroidChart</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/08/2015-02-08-canvas-matrix/" itemprop="url">
                  Android中绘图学习笔记(三)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-08T00:00:00+08:00" content="2015-02-08">
              2015-02-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/02/08/2015-02-08-canvas-matrix/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/02/08/2015-02-08-canvas-matrix/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          matrix
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/02/08/2015-02-08-canvas-matrix/">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/01/2015-02-01-canvas-2/" itemprop="url">
                  Android中绘图学习笔记(二)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-01T00:00:00+08:00" content="2015-02-01">
              2015-02-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/02/01/2015-02-01-canvas-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/02/01/2015-02-01-canvas-2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p>上一节我们讲到了canvas可以绘制很多的图形，现在就来看看它的具体使用方法</p>
<h5 id="点"><a href="#点" class="headerlink" title="点"></a>点</h5><ol>
<li><p>一个点:</p>
<pre><code>drawPoint(float x, float y, Paint paint) //x:水平x轴，y:垂直y轴，第三个参数为Paint对象。
</code></pre></li>
<li><p>多个点：</p>
<pre><code>drawPoints (float[] pts, Paint paint)

drawPoints (float[] pts, int offset, int count, Paint paint) 

 eg:canvas.drawPoints(new float[]{20f, 20f, 120f, 20f, 120f, 120f, 20f, 120f}, painnt)//每个端点占用两个数据。
</code></pre></li>
</ol>
<h5 id="线"><a href="#线" class="headerlink" title="线"></a>线</h5><ol>
<li><p>一条线:</p>
<pre><code>drawLine(float startX, float startY, float stopX, float stopY,
    @NonNull Paint paint) {
</code></pre></li>
<li><p>多条线：</p>
<pre><code>drawLines(@NonNull float[] pts, @NonNull Paint paint) //每条线占用4个数据即起点和终点
</code></pre></li>
</ol>
<h5 id="面"><a href="#面" class="headerlink" title="面"></a>面</h5><p>面又分为很多种，分不同的形状，比如</p>
<h6 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h6><pre><code>drawRect(@NonNull Rect r, @NonNull Paint paint)

drawRect(float left, float top, float right, float bottom, @NonNull Paint paint)

drawRect(@NonNull RectF rect, @NonNull Paint paint)

drawRoundRect(@NonNull RectF rect, float rx, float ry, @NonNull Paint paint)//花带圆角的矩形

//Rect跟RectF区别只是精度不同
</code></pre><h6 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h6><pre><code>drawCircle(float cx, float cy, float radius, @NonNull Paint paint) 
</code></pre><h6 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h6><pre><code>drawOval(@NonNull RectF oval, @NonNull Paint paint)
</code></pre><h6 id="自定义饼状图形和圆弧（如扇型）"><a href="#自定义饼状图形和圆弧（如扇型）" class="headerlink" title="自定义饼状图形和圆弧（如扇型）"></a>自定义饼状图形和圆弧（如扇型）</h6><pre><code>drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter,
        @NonNull Paint paint) //oval为圆的矩形范围，startAngle为起始角度，sweepAngle为需要滑过的角度，默认0点在右边，sweep是按顺时针转,useCenter代表圆是否封闭
</code></pre><h6 id="绘制自定义图形（如三角形，五角星）"><a href="#绘制自定义图形（如三角形，五角星）" class="headerlink" title="绘制自定义图形（如三角形，五角星）"></a>绘制自定义图形（如三角形，五角星）</h6><pre><code>Path path = new Path();
path.moveTo(27, 360);
path.lineTo(54, 360);
path.lineTo(70, 392);
path.lineTo(40, 420);
path.lineTo(10, 392);
path.close();
//根据Path进行绘制，绘制五角星
canvas.drawPath(path2, paint);
</code></pre><h6 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h6><pre><code> drawText(@NonNull String text, float x, float y, @NonNull Paint paint) 

其他几个方法类似就不举例，注意此处要通过paint设置字体的大小，粗细，颜色 等等   
</code></pre><h6 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h6><pre><code>drawBitmap(bitmap, null, rect, paint);//rect设置其画在某个区域内

drawBitmap(@NonNull Bitmap bitmap, @NonNull Matrix matrix, @Nullable Paint paint) //matrix我还没弄清楚，下次再补上
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/25/2015-01-25-canvas-1/" itemprop="url">
                  Android中绘图学习笔记(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-25T00:00:00+08:00" content="2015-01-25">
              2015-01-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/01/25/2015-01-25-canvas-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/01/25/2015-01-25-canvas-1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近项目中要用到图表，但是现有的开源图表库不能满足我们的要求，所以要去修改它的源码，发现所有的图表库都用的是Canvas去画的，之前没有研究过它的绘制原理，接下来将其学习笔记记录与此</p>
<h2 id="绘图三要素"><a href="#绘图三要素" class="headerlink" title="绘图三要素"></a>绘图三要素</h2><p>Paint—————画笔</p>
<p>Bitmap————–画布</p>
<p>Canvas————–画家</p>
<p>它们三个是紧密相连的，缺一不可，不管我们画任何图形，文字，都需要用到它们</p>
<h2 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h2><p>Bitmap的创建有很多</p>
<ol>
<li>Bitmap.createBitmap()(Api提供了六种重载)</li>
<li><p>使用BitmapFactory获取位图 </p>
<pre><code>Bitmap bmp=BitmapFactory.decodeResource(res, R.drawable.ic_launcher);
</code></pre></li>
<li><p>…</p>
</li>
</ol>
<p>Canvas对象的获取方式有两种：</p>
<ol>
<li>一种我们通过重写View.onDraw方法，View中的Canvas对象会被当做参数传递过来，我们操作这个Canvas，效果会直接反应在View中。</li>
<li><p>另一种就是当你想创建一个Canvas对象时使用的方法：</p>
<pre><code>Bitmap b = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);   
Canvas c = new Canvas(b);
</code></pre><p>上面代码创建了一个尺寸是100*100的Bitmap，使用它作为Canvas操作的对象，这时候的Canvas就是使用创建的方式</p>
</li>
</ol>
<p>Paint的创建最简单<br> Paint paint = new Paint();  关于Paint的属性介绍，可以参考如下地址：<a href="http://blog.csdn.net/xanxus46/article/details/7883554" target="_blank" rel="external">http://blog.csdn.net/xanxus46/article/details/7883554</a></p>
<h2 id="绘图种类"><a href="#绘图种类" class="headerlink" title="绘图种类"></a>绘图种类</h2><ol>
<li>弧线(arcs)</li>
<li>填充颜色(argb和color)</li>
<li>Bitmap</li>
<li>圆(circle和oval)</li>
<li>点(point)</li>
<li>线(line)</li>
<li>矩形(Rect)</li>
<li>图片(Picture)</li>
<li>圆角矩形 (RoundRect)</li>
<li>文本(text)</li>
<li>顶点(Vertices)</li>
<li>路径(path)</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/25/2014-12-25-scrollview-webview-anchor/" itemprop="url">
                  scrollview嵌套webview导致锚点无法使用的解决方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-25T00:00:00+08:00" content="2014-12-25">
              2014-12-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/12/25/2014-12-25-scrollview-webview-anchor/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/12/25/2014-12-25-scrollview-webview-anchor/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在开发者中碰到一个头疼的问题，发现webview嵌套在scrollview中后，webview的锚点定位功能失效，经过查阅一番折腾后发现还是没找到很好的方法解决，于是想了另外一种方法，</p>
<p><strong>思路</strong>：通过计算目标点在scrollview的位置top，调用<code>scrollTo(0,top)</code>方法定位</p>
<p><strong>实现</strong>：页面布局是这样的</p>
<pre><code>&lt;ScrollView&gt;
    &lt;View&gt;

    &lt;/View&gt;
    &lt;WebView&gt;
        &lt;div id=&quot;anchor&quot;&gt;&lt;/div&gt; 
    &lt;/WebView&gt;
&lt;/ScrollView&gt;
</code></pre><p>so top=height(View)+height(div)</p>
<p>首先View到顶部的距离好说，view.getTop即可，代码如下：</p>
<pre><code>/**
 * 测量商品信息导航栏离顶端高度
 */
private void getTopForNav() {
    ViewTreeObserver vto = rg_info_nav.getViewTreeObserver();
    vto.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener()         {
        public boolean onPreDraw() {
            mHeight = rg_info_nav.getTop();
            return true;
        }
    });
}
</code></pre><p>问题来了，怎么计算webview中某个节点离webview顶端的距离呢，没错，就是通过js计算，然后通过alert（）弹出，在android中就可以拿到了，代码如下：</p>
<p>js:</p>
<pre><code>function d_desc(){
    var desc = document.getElementById(&quot;desc&quot;);
     var topa = desc.offsetTop;
     alert(topa);
}
</code></pre><p>android:</p>
<pre><code>mWebView.setWebChromeClient(new WebChromeClient() {

        @Override
        public boolean onJsAlert(WebView view, String url, String message, JsResult result) {
            result.cancel();
            if (!TextUtils.isEmpty(message)) {
                try {
                    int top = Integer.parseInt(message);
                    mStickyScrollView.scrollTo(0, mHeight + (int) (top * mDensity));
                } catch (Exception e) {
                }

            }
            return true;
        }
    });

//mDensity=getResources().getDisplayMetrics().density;屏幕密度
</code></pre><p>在需要定位的地方调用即可：</p>
<pre><code>mWebView.loadUrl(&quot;javascript: d_desc()&quot;);
</code></pre><h3 id="疑点"><a href="#疑点" class="headerlink" title="疑点"></a>疑点</h3><p><code>top * mDensity</code>：通过js获取到的top值就是px，mHeigh获取到的也是px，但是如果调用scrollTo（mHeigh+top）位置会不对，必须写成scrollTo（mHeigh+top*mDensity），此问题暂时在此mark,待弄清楚后再来解释</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/loofee.png"
               alt="loody" />
          <p class="site-author-name" itemprop="name">loody</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">35</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">50</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/loody" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2396231120/profile?topnav=1&wvr=6&is_all=1" target="_blank">
                  
                    <i class="fa fa-globe"></i> weibo
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">loody</span>
</div>

<div class="powered-by">
  <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"loody"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  


</body>
</html>
