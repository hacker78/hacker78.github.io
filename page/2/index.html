<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="loody's blog">
<meta property="og:url" content="http://loody.github.io/page/2/index.html">
<meta property="og:site_name" content="loody's blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="loody's blog">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> loody's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?f99c8e8fc92fd70fbf50a1494cf47607";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">loody's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/08/2015-03-08-hellocharts/" itemprop="url">
                  hellocharts与MPAndroidChart的比较
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-08T00:00:00+08:00" content="2015-03-08">
              2015-03-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/03/08/2015-03-08-hellocharts/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/03/08/2015-03-08-hellocharts/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记得之前介绍过关于MPAndroidChart的使用方法，但是长江后浪推前浪，最近github有出了一个新的开源曲线库，hellocharts,个人觉得这个库比MPAndroidChart更加酷炫，下面就介绍下它的一些使用方法</p>
<p>github地址：<a href="https://github.com/lecho/hellocharts-android" target="_blank" rel="external">https://github.com/lecho/hellocharts-android</a></p>
<h2 id="使用方法（同样以曲线为例，其他类似）"><a href="#使用方法（同样以曲线为例，其他类似）" class="headerlink" title="使用方法（同样以曲线为例，其他类似）"></a>使用方法（同样以曲线为例，其他类似）</h2><ul>
<li><p>xml</p>
<pre><code>&lt;lecho.lib.hellocharts.view.LineChartView 
    android:id=&quot;@+id/linechart&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;/&gt;
</code></pre></li>
<li><p>code</p>
<pre><code>LineChartView chart = new LineChartView(context);
layout.addView(chart);
</code></pre></li>
<li><p>data    </p>
<pre><code>List&lt;PointValue&gt; values = new ArrayList&lt;PointValue&gt;();
values.add(new PointValue(x,y));
...

   Line line = new Line(values);
List&lt;Line&gt; lines = new ArrayList&lt;Line&gt;();
lines.add(line);//可以有多条曲线

LineChartData data = new LineChartData();
data.setLines(lines);

chart.setLineChartData(data);
</code></pre></li>
</ul>
<h2 id="hellocharts和MPAndroidChart的比较"><a href="#hellocharts和MPAndroidChart的比较" class="headerlink" title="hellocharts和MPAndroidChart的比较"></a>hellocharts和MPAndroidChart的比较</h2><h2 id="曲线的样式"><a href="#曲线的样式" class="headerlink" title="曲线的样式"></a>曲线的样式</h2><p>在这一点上，MPAndroidChart比hellocharts要好，MPAndroidChart对曲线的样式非常的详细，包括曲线的颜色，粗细、样式（实线、虚线），曲线上点的颜色、粗细、形状，选中的点的图例（类似地图的标注，还可以自定义布局样式）、单位，整个图标的图例（每条曲线的颜色，标题等信息），曲线的上下限标识，x轴，Y轴的字体颜色，大小，字体样式等</p>
<p>特别说明：</p>
<ol>
<li><p>hellocharts在曲线的颜色，点的颜色，还有点的背景颜色默认是保持一致的，没法配置，这个比较伤脑筋，</p>
</li>
<li><p>MPAndroidChart不能在<code>set.setCubic(true)</code>模式下支持自定义<code>setFillColor()</code>;</p>
<p> 如果说对这些要求比较高的就要慎重选择了</p>
</li>
</ol>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>MPAndroidChart更方便一点，它支持三种动画</p>
<pre><code>animateX(int durationMillis):
 animateY(int durationMillis):
  animateXY(int xDuration, int yDuration): 
</code></pre><p>hellocharts也可以自定义动画的</p>
<pre><code>chartTop.setAnimation();
</code></pre><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>hellocharts更加灵活，它可以设置图标的缩放方向，而MPAndroidChart不能单独指定</p>
<pre><code>chartTop.setZoomType(ZoomType.HORIZONTAL);
//ZoomType:HORIZONTAL、VERTICAL、HORIZONTAL_AND_VERTICAL
</code></pre><h2 id="分页展示与滑动"><a href="#分页展示与滑动" class="headerlink" title="分页展示与滑动"></a>分页展示与滑动</h2><p>两个库在这个方面的表现差异很大，hellocharts的体验优势很大，下面我们详细说说这个</p>
<ol>
<li><p>单屏</p>
<p> MPAndroidChart默认是将所有的点都展示在一个屏幕上，这样一来，点少还可以，一旦点特别多的时候，展示就很难看，根本看不清楚点的x,y值，必须手动去缩放才能看清，很麻烦，图标展示就没有了意义.有人说，是不是可以通过通过设置曲线默认的缩放比例<code>mChart.setScaleMinima();</code>来达到分页展示的目的，事实上是可以的，但是效果很不好，很容易又恢复单屏显示</p>
</li>
<li><p>滑动不流畅</p>
<p>  MPAndroidChart的滑动是没有惯性的，只能手指贴面滑，体验很不好</p>
<p>有时候要展示的数据比较多，以上两个限制对用户的体验式致命的，还好，hellocharts解决了这两个问题，怎么解决的呢？</p>
<p>在hellocharts中引入了一个Viewport的东西，作者的解释是：<br>**The viewport is represented by the coordinates of its 4 edges (left, top, right</p>
<ul>
<li>bottom). These fields can be accessed directly. Use width() and height() to retrieve the viewport’s width and height.**</li>
</ul>
<p>我的理解，Viewport就是一个视图的概念，这个视图有上下左右四个边，好比一张全国地图，我们只想看某个省份的地图，所以我们只需要拿到某个省份的上下左右边界，然后展示出来就可以了，他就是全国地图中的一个子集</p>
<p>  public Viewport(float left, float top, float right, float bottom) </p>
<p>hellocharts有两个方法</p>
<p>  chartTop.setMaximumViewport(Viewport maxViewport)//所有的视图<br> chartTop.setCurrentViewport(Viewport targetViewport);//当前要展示的视图</p>
</li>
</ol>
<p>我们需要拿到左右数据的最大视图范围和当前要展示的视图范围，调用上面两个方法，即可完成数据的分页展示，关键是这个曲线库的滑动非常流程，体验非常赞</p>
<p>综上，如果大家要展示的数据比较少，对曲线样式，动画要求很高的可以选择MPAndroidChart，反之就选择hellocharts吧，当然具体情况还得自己斟酌，</p>
<p>ps:两个库的作者对项目维护活跃的都很高，MPAndroidChart最近也提供了gradle依赖，使用android studio的同学用起来更方便了    ，具体更新请随时关注github.</p>
<p>hellocharts：<a href="https://github.com/lecho/hellocharts-android" target="_blank" rel="external">https://github.com/lecho/hellocharts-android</a></p>
<p>MPAndroidChart：<a href="https://github.com/PhilJay/MPAndroidChart" target="_blank" rel="external">https://github.com/PhilJay/MPAndroidChart</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/08/2015-02-08-canvas-matrix/" itemprop="url">
                  Android中绘图学习笔记(三)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-08T00:00:00+08:00" content="2015-02-08">
              2015-02-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/02/08/2015-02-08-canvas-matrix/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/02/08/2015-02-08-canvas-matrix/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          matrix
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/02/08/2015-02-08-canvas-matrix/">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/01/2015-02-01-canvas-2/" itemprop="url">
                  Android中绘图学习笔记(二)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-01T00:00:00+08:00" content="2015-02-01">
              2015-02-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/02/01/2015-02-01-canvas-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/02/01/2015-02-01-canvas-2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p>上一节我们讲到了canvas可以绘制很多的图形，现在就来看看它的具体使用方法</p>
<h5 id="点"><a href="#点" class="headerlink" title="点"></a>点</h5><ol>
<li><p>一个点:</p>
<pre><code>drawPoint(float x, float y, Paint paint) //x:水平x轴，y:垂直y轴，第三个参数为Paint对象。
</code></pre></li>
<li><p>多个点：</p>
<pre><code>drawPoints (float[] pts, Paint paint)

drawPoints (float[] pts, int offset, int count, Paint paint) 

 eg:canvas.drawPoints(new float[]{20f, 20f, 120f, 20f, 120f, 120f, 20f, 120f}, painnt)//每个端点占用两个数据。
</code></pre></li>
</ol>
<h5 id="线"><a href="#线" class="headerlink" title="线"></a>线</h5><ol>
<li><p>一条线:</p>
<pre><code>drawLine(float startX, float startY, float stopX, float stopY,
    @NonNull Paint paint) {
</code></pre></li>
<li><p>多条线：</p>
<pre><code>drawLines(@NonNull float[] pts, @NonNull Paint paint) //每条线占用4个数据即起点和终点
</code></pre></li>
</ol>
<h5 id="面"><a href="#面" class="headerlink" title="面"></a>面</h5><p>面又分为很多种，分不同的形状，比如</p>
<h6 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h6><pre><code>drawRect(@NonNull Rect r, @NonNull Paint paint)

drawRect(float left, float top, float right, float bottom, @NonNull Paint paint)

drawRect(@NonNull RectF rect, @NonNull Paint paint)

drawRoundRect(@NonNull RectF rect, float rx, float ry, @NonNull Paint paint)//花带圆角的矩形

//Rect跟RectF区别只是精度不同
</code></pre><h6 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h6><pre><code>drawCircle(float cx, float cy, float radius, @NonNull Paint paint) 
</code></pre><h6 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h6><pre><code>drawOval(@NonNull RectF oval, @NonNull Paint paint)
</code></pre><h6 id="自定义饼状图形和圆弧（如扇型）"><a href="#自定义饼状图形和圆弧（如扇型）" class="headerlink" title="自定义饼状图形和圆弧（如扇型）"></a>自定义饼状图形和圆弧（如扇型）</h6><pre><code>drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter,
        @NonNull Paint paint) //oval为圆的矩形范围，startAngle为起始角度，sweepAngle为需要滑过的角度，默认0点在右边，sweep是按顺时针转,useCenter代表圆是否封闭
</code></pre><h6 id="绘制自定义图形（如三角形，五角星）"><a href="#绘制自定义图形（如三角形，五角星）" class="headerlink" title="绘制自定义图形（如三角形，五角星）"></a>绘制自定义图形（如三角形，五角星）</h6><pre><code>Path path = new Path();
path.moveTo(27, 360);
path.lineTo(54, 360);
path.lineTo(70, 392);
path.lineTo(40, 420);
path.lineTo(10, 392);
path.close();
//根据Path进行绘制，绘制五角星
canvas.drawPath(path2, paint);
</code></pre><h6 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h6><pre><code> drawText(@NonNull String text, float x, float y, @NonNull Paint paint) 

其他几个方法类似就不举例，注意此处要通过paint设置字体的大小，粗细，颜色 等等   
</code></pre><h6 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h6><pre><code>drawBitmap(bitmap, null, rect, paint);//rect设置其画在某个区域内

drawBitmap(@NonNull Bitmap bitmap, @NonNull Matrix matrix, @Nullable Paint paint) //matrix我还没弄清楚，下次再补上
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/25/2015-01-25-canvas-1/" itemprop="url">
                  Android中绘图学习笔记(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-25T00:00:00+08:00" content="2015-01-25">
              2015-01-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/01/25/2015-01-25-canvas-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/01/25/2015-01-25-canvas-1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近项目中要用到图表，但是现有的开源图表库不能满足我们的要求，所以要去修改它的源码，发现所有的图表库都用的是Canvas去画的，之前没有研究过它的绘制原理，接下来将其学习笔记记录与此</p>
<h2 id="绘图三要素"><a href="#绘图三要素" class="headerlink" title="绘图三要素"></a>绘图三要素</h2><p>Paint—————画笔</p>
<p>Bitmap————–画布</p>
<p>Canvas————–画家</p>
<p>它们三个是紧密相连的，缺一不可，不管我们画任何图形，文字，都需要用到它们</p>
<h2 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h2><p>Bitmap的创建有很多</p>
<ol>
<li>Bitmap.createBitmap()(Api提供了六种重载)</li>
<li><p>使用BitmapFactory获取位图 </p>
<pre><code>Bitmap bmp=BitmapFactory.decodeResource(res, R.drawable.ic_launcher);
</code></pre></li>
<li><p>…</p>
</li>
</ol>
<p>Canvas对象的获取方式有两种：</p>
<ol>
<li>一种我们通过重写View.onDraw方法，View中的Canvas对象会被当做参数传递过来，我们操作这个Canvas，效果会直接反应在View中。</li>
<li><p>另一种就是当你想创建一个Canvas对象时使用的方法：</p>
<pre><code>Bitmap b = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);   
Canvas c = new Canvas(b);
</code></pre><p>上面代码创建了一个尺寸是100*100的Bitmap，使用它作为Canvas操作的对象，这时候的Canvas就是使用创建的方式</p>
</li>
</ol>
<p>Paint的创建最简单<br> Paint paint = new Paint();  关于Paint的属性介绍，可以参考如下地址：<a href="http://blog.csdn.net/xanxus46/article/details/7883554" target="_blank" rel="external">http://blog.csdn.net/xanxus46/article/details/7883554</a></p>
<h2 id="绘图种类"><a href="#绘图种类" class="headerlink" title="绘图种类"></a>绘图种类</h2><ol>
<li>弧线(arcs)</li>
<li>填充颜色(argb和color)</li>
<li>Bitmap</li>
<li>圆(circle和oval)</li>
<li>点(point)</li>
<li>线(line)</li>
<li>矩形(Rect)</li>
<li>图片(Picture)</li>
<li>圆角矩形 (RoundRect)</li>
<li>文本(text)</li>
<li>顶点(Vertices)</li>
<li>路径(path)</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/25/2014-12-25-scrollview-webview-anchor/" itemprop="url">
                  scrollview嵌套webview导致锚点无法使用的解决方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-25T00:00:00+08:00" content="2014-12-25">
              2014-12-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/12/25/2014-12-25-scrollview-webview-anchor/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/12/25/2014-12-25-scrollview-webview-anchor/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在开发者中碰到一个头疼的问题，发现webview嵌套在scrollview中后，webview的锚点定位功能失效，经过查阅一番折腾后发现还是没找到很好的方法解决，于是想了另外一种方法，</p>
<p><strong>思路</strong>：通过计算目标点在scrollview的位置top，调用<code>scrollTo(0,top)</code>方法定位</p>
<p><strong>实现</strong>：页面布局是这样的</p>
<pre><code>&lt;ScrollView&gt;
    &lt;View&gt;

    &lt;/View&gt;
    &lt;WebView&gt;
        &lt;div id=&quot;anchor&quot;&gt;&lt;/div&gt; 
    &lt;/WebView&gt;
&lt;/ScrollView&gt;
</code></pre><p>so top=height(View)+height(div)</p>
<p>首先View到顶部的距离好说，view.getTop即可，代码如下：</p>
<pre><code>/**
 * 测量商品信息导航栏离顶端高度
 */
private void getTopForNav() {
    ViewTreeObserver vto = rg_info_nav.getViewTreeObserver();
    vto.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener()         {
        public boolean onPreDraw() {
            mHeight = rg_info_nav.getTop();
            return true;
        }
    });
}
</code></pre><p>问题来了，怎么计算webview中某个节点离webview顶端的距离呢，没错，就是通过js计算，然后通过alert（）弹出，在android中就可以拿到了，代码如下：</p>
<p>js:</p>
<pre><code>function d_desc(){
    var desc = document.getElementById(&quot;desc&quot;);
     var topa = desc.offsetTop;
     alert(topa);
}
</code></pre><p>android:</p>
<pre><code>mWebView.setWebChromeClient(new WebChromeClient() {

        @Override
        public boolean onJsAlert(WebView view, String url, String message, JsResult result) {
            result.cancel();
            if (!TextUtils.isEmpty(message)) {
                try {
                    int top = Integer.parseInt(message);
                    mStickyScrollView.scrollTo(0, mHeight + (int) (top * mDensity));
                } catch (Exception e) {
                }

            }
            return true;
        }
    });

//mDensity=getResources().getDisplayMetrics().density;屏幕密度
</code></pre><p>在需要定位的地方调用即可：</p>
<pre><code>mWebView.loadUrl(&quot;javascript: d_desc()&quot;);
</code></pre><h3 id="疑点"><a href="#疑点" class="headerlink" title="疑点"></a>疑点</h3><p><code>top * mDensity</code>：通过js获取到的top值就是px，mHeigh获取到的也是px，但是如果调用scrollTo（mHeigh+top）位置会不对，必须写成scrollTo（mHeigh+top*mDensity），此问题暂时在此mark,待弄清楚后再来解释</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/21/2014-12-21-weixin-pay/" itemprop="url">
                  微信支付需要注意的几个问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-21T00:00:00+08:00" content="2014-12-21">
              2014-12-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/12/21/2014-12-21-weixin-pay/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/12/21/2014-12-21-weixin-pay/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上周在项目中增加了支持微信支付的功能，遇到了不少问题，现将其mark如下</p>
<h2 id="微信支付流程"><a href="#微信支付流程" class="headerlink" title="微信支付流程"></a>微信支付流程</h2><ol>
<li><p>获取access_token()<br> 这步需要用到<code>APP_ID</code> 和 <code>APP_SECRET</code>，需要在微信开放平台注册应用获得</p>
</li>
<li><p>生成预支付订单 </p>
</li>
<li><p>调起微信支付</p>
</li>
<li><p>支付完成后</p>
<p> 微信会回调 WXPayEntryActivity 的public void onResp(BaseResp resp)方法，所以后续操作，放在这个回调函数中操作就可以了。</p>
<p> resp.errCode== 0 ：表示支付成功</p>
<p> resp.errCode== -1 ：表示支付失败</p>
<p> resp.errCode== -2 ：表示取消支付</p>
<p>具体步骤大家可以去微信开放平台下载demo文档查看，地址是：<a href="https://open.weixin.qq.com/paymch/readtemplate?t=open/resource/app_wx_pay_android_tmpl" target="_blank" rel="external">https://open.weixin.qq.com/paymch/readtemplate?t=open/resource/app_wx_pay_android_tmpl</a></p>
<p>官方建议，为安全起见，上面步骤一和步骤二建议放在服务端完成，客户端拿到这些参数直接掉起PayReq，设置完参数完成支付</p>
</li>
</ol>
<h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><p><strong>1、 每次运行点完支付都返回-1，即支付失败，并不能调出支付确认界面，原因可能是如下几个原因：</strong></p>
<ol>
<li>这个问题多半是签名错误，或者keystore，包名，签名不一致导致。</li>
<li>再有错误，就是你第二步生成Prepayid时的app_signature 生成错误，仔细看下demo和文档。</li>
</ol>
<p>demo中有一个debug.store可以作为测试签名文件，可以直接掉出支付页面，eclipse(目前文档是基于eclipse的，用as的同学请见谅)步骤如下：<br>Window-&gt;Preferences-&gt;Android-&gt;Build-&gt;指定Custom debug keystore选项的路径为sdk demo工程目录中的debug.keystore文件<br>运行，程序，进入支付页面即可调出支付页面了，如下</p>
<p><img src="/images/wx_pay.jpg" alt="wx_pay.jpg"></p>
<p><strong>2、可以弹出微信支付的界面，但是支付之后没有进入回调的Activity：WXPayEntryActivity ?
</strong><br>微信开放平台有个 不成文的规定（文档里没有说明），就是回调的Activity必须是：你的包名（微信demo里是：net.sourceforge.simcpux）+.wxapi.WXPayEntryActivity.java<br>其他的接口回调的Activity必须是：你的包名（微信demo里是：net.sourceforge.simcpux）+.wxapi.WXEntryActivity.java,<br>而且这两个回调的Activity必须要实现IWXAPIEventHandler的接口 。(抓瞎)</p>
<p><strong>3、项目中用到了友盟社会化分享组件，jar包处理问题</strong><br>如果你的项目中用到了友盟集成的关于微信的功能，友盟中有两个关于微信的jar包<br><code>SocialSDK_WeiXin_1</code>、<code>SocialSDK_WeiXin_2</code>，<br>其中SocialSDK_WeiXin_1就是微信功能的原生jar包（libammsdk.jar），所有关于微信的功能都在这个jar包里，大家只需替换这个jar包即可完成升级。SocialSDK_WeiXin_2继续保留<br>友盟只是对微信的包名做了修改（libammsdk.jar -&gt; SocialSDK_WeiXin_1.jar）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/14/2014-12-14-string-format/" itemprop="url">
                  android中的常见的占位符及转义字符
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-14T00:00:00+08:00" content="2014-12-14">
              2014-12-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/12/14/2014-12-14-string-format/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/12/14/2014-12-14-string-format/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="常见的几种占位符-String-format"><a href="#常见的几种占位符-String-format" class="headerlink" title="常见的几种占位符 String.format"></a>常见的几种占位符 String.format</h2><ul>
<li>%d: 整数类型(十进制)，如：99，其中%04d表示在前面补0，即0099</li>
<li>%f: 浮点类型，如：99.99 其中%.2f表示保留两位小数</li>
<li>%s: 字符串类型，如：”ljq”</li>
<li>%b: 布尔类型，如：true</li>
<li>%%: 百分比类型，如：％</li>
<li>%n: 换行符</li>
</ul>
<h2 id="对整数进行格式化：-index-标识-最小宽度-转换方式"><a href="#对整数进行格式化：-index-标识-最小宽度-转换方式" class="headerlink" title="对整数进行格式化：%[index$][标识][最小宽度]转换方式"></a>对整数进行格式化：%[index$][标识][最小宽度]转换方式</h2><p>我们可以看到，格式化字符串由4部分组成，其中%[index$]的含义我们上面已经讲过，[最小宽度]的含义也很好理解，就是最终该整数转化的字符串最少包含多少位数字。我们来看看剩下2个部分的含义吧：</p>
<h3 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h3><ul>
<li>‘-‘    在最小宽度内左对齐，不可以与“用0填充”同时使用</li>
<li>‘#’    只适用于8进制和16进制，8进制时在结果前面增加一个0，16进制时在结果前面增加0x</li>
<li>‘+’    结果总是包括一个符号（一般情况下只适用于10进制，若对象为BigInteger才可以用于8进制和16进制）</li>
<li>‘ ‘    正值前加空格，负值前加负号（一般情况下只适用于10进制，若对象为BigInteger才可以用于8进制和16进制）</li>
<li>‘0’    结果将用零来填充</li>
<li>‘,’    只适用于10进制，每3位数字之间用“，”分隔</li>
<li>‘(‘    若参数是负数，则结果中不添加负号而是用圆括号把数字括起来（同‘+’具有同样的限制）</li>
</ul>
<h3 id="转换方式"><a href="#转换方式" class="headerlink" title="转换方式"></a>转换方式</h3><p>d:十进制<br>o:八进制<br>x或X:十六进制</p>
<h2 id="对浮点数进行格式化：-index-标识-最少宽度-精度-转换方式"><a href="#对浮点数进行格式化：-index-标识-最少宽度-精度-转换方式" class="headerlink" title="对浮点数进行格式化：%[index$][标识][最少宽度][.精度]转换方式"></a>对浮点数进行格式化：%[index$][标识][最少宽度][.精度]转换方式</h2><p>我们可以看到，浮点数的转换多了一个“精度”选项，可以控制小数点后面的位数。</p>
<h3 id="标识-1"><a href="#标识-1" class="headerlink" title="标识"></a>标识</h3><ul>
<li>‘-‘    在最小宽度内左对齐，不可以与“用0填充”同时使用</li>
<li>‘+’    结果总是包括一个符号</li>
<li>‘  ‘    正值前加空格，负值前加负号</li>
<li>‘0’    结果将用零来填充</li>
<li>‘,’    每3位数字之间用“，”分隔（只适用于fgG的转换）</li>
<li>‘(‘    若参数是负数，则结果中不添加负号而是用圆括号把数字括起来（只适用于eEfgG的转换）</li>
</ul>
<h3 id="转换方式-1"><a href="#转换方式-1" class="headerlink" title="转换方式"></a>转换方式</h3><ul>
<li>‘e’, ‘E’  –  结果被格式化为用计算机科学记数法表示的十进制数</li>
<li>‘f’          –  结果被格式化为十进制普通表示方式</li>
<li>‘g’, ‘G’    –  根据具体情况，自动选择用普通表示方式还是科学计数法方式</li>
<li>‘a’, ‘A’    –   结果被格式化为带有效位数和指数的十六进制浮点数</li>
</ul>
<h2 id="对字符进行格式化："><a href="#对字符进行格式化：" class="headerlink" title="对字符进行格式化："></a>对字符进行格式化：</h2><p>对字符进行格式化是非常简单的，c表示字符，标识中’-‘表示左对齐，其他就没什么了。</p>
<h2 id="对百分比符号进行格式化："><a href="#对百分比符号进行格式化：" class="headerlink" title="对百分比符号进行格式化："></a>对百分比符号进行格式化：</h2><p>看了上面的说明，大家会发现百分比符号“%”是特殊格式的一个前缀。那么我们要输入一个百分比符号该怎么办呢？肯定是需要转义字符的,但是要注意的是，在这里转义字符不是“\”，而是“%”。</p>
<h2 id="取得平台独立的行分隔符："><a href="#取得平台独立的行分隔符：" class="headerlink" title="取得平台独立的行分隔符："></a>取得平台独立的行分隔符：</h2><p><code>System.getProperty(&quot;line.separator&quot;)</code>可以取得平台独立的行分隔符，但是用在format中间未免显得过于烦琐了。于是format函数自带了一个平台独立的行分隔符那就是<br><code>String.format(&quot;%n&quot;)</code>。</p>
<h2 id="对日期类型进行格式化"><a href="#对日期类型进行格式化" class="headerlink" title="对日期类型进行格式化:"></a>对日期类型进行格式化:</h2><p>以下日期和时间转换的后缀字符是为 ‘t’ 和 ‘T’ 转换定义的。这些类型相似于但不完全等同于那些由 GNU date 和 POSIX strftime(3c) 定义的类型。提供其他转换类型是为了访问特定于 Java 的功能（如将 ‘L’ 用作秒中的毫秒）。</p>
<p><strong>以下转换字符用来格式化时间：</strong></p>
<ul>
<li>‘H’     24 小时制的小时，被格式化为必要时带前导零的两位数，即 00 - 23。</li>
<li>‘I’     12 小时制的小时，被格式化为必要时带前导零的两位数，即 01 - 12。</li>
<li>‘k’     24 小时制的小时，即 0 - 23。</li>
<li>‘l’     12 小时制的小时，即 1 - 12。</li>
<li>‘M’     小时中的分钟，被格式化为必要时带前导零的两位数，即 00 - 59。</li>
<li>‘S’     分钟中的秒，被格式化为必要时带前导零的两位数，即 00 - 60 （”60” 是支持闰秒所需的一个特殊值）。</li>
<li>‘L’     秒中的毫秒，被格式化为必要时带前导零的三位数，即 000 - 999。</li>
<li>‘N’     秒中的毫微秒，被格式化为必要时带前导零的九位数，即 000000000 - 999999999。</li>
<li>‘p’     特定于语言环境的 上午或下午 标记以小写形式表示，例如 “am” 或 “pm”。使用转换前缀 ‘T’ 可以强行将此输出转换为大写形式。</li>
<li>‘z’     相对于 GMT 的 RFC 822 格式的数字时区偏移量，例如 -0800。</li>
<li>‘Z’     表示时区缩写形式的字符串。Formatter 的语言环境将取代参数的语言环境（如果有）。</li>
<li>‘s’     自协调世界时 (UTC) 1970 年 1 月 1 日 00:00:00 至现在所经过的秒数，即 Long.MIN_VALUE/1000 与 Long.MAX_VALUE/1000 之间的差值。</li>
<li>‘Q’     自协调世界时 (UTC) 1970 年 1 月 1 日 00:00:00 至现在所经过的毫秒数，即 Long.MIN_VALUE 与 Long.MAX_VALUE 之间的差值。</li>
</ul>
<p><strong>以下转换字符用来格式化日期：</strong></p>
<ul>
<li>‘B’     特定于语言环境的月份全称，例如 “January” 和 “February”。</li>
<li>‘b’     特定于语言环境的月份简称，例如 “Jan” 和 “Feb”。</li>
<li>‘h’     与 ‘b’ 相同。</li>
<li>‘A’     特定于语言环境的星期几全称，例如 “Sunday” 和 “Monday”</li>
<li>‘a’     特定于语言环境的星期几简称，例如 “Sun” 和 “Mon”</li>
<li>‘C’     除以 100 的四位数表示的年份，被格式化为必要时带前导零的两位数，即 00 - 99</li>
<li>‘Y’     年份，被格式化为必要时带前导零的四位数（至少），例如，0092 等于格里高利历的 92 CE。</li>
<li>‘y’     年份的最后两位数，被格式化为必要时带前导零的两位数，即 00 - 99。</li>
<li>‘j’     一年中的天数，被格式化为必要时带前导零的三位数，例如，对于格里高利历是 001 - 366。</li>
<li>‘m’     月份，被格式化为必要时带前导零的两位数，即 01 - 13。</li>
<li>‘d’     一个月中的天数，被格式化为必要时带前导零两位数，即 01 - 31</li>
<li>‘e’     一个月中的天数，被格式化为两位数，即 1 - 31。</li>
</ul>
<p><strong>以下转换字符用于格式化常见的日期/时间组合。</strong></p>
<ul>
<li>‘R’     24 小时制的时间，被格式化为 “%tH:%tM”</li>
<li>‘T’     24 小时制的时间，被格式化为 “%tH:%tM:%tS”。</li>
<li>‘r’     12 小时制的时间，被格式化为 “%tI:%tM:%tS %Tp”。上午或下午标记 (‘%Tp’) 的位置可能与语言环境有关。</li>
<li>‘D’     日期，被格式化为 “%tm/%td/%ty”。</li>
<li>‘F’     ISO 8601 格式的完整日期，被格式化为 “%tY-%tm-%td”。</li>
<li>‘c’     日期和时间，被格式化为 “%ta %tb %td %tT %tZ %tY”，例如 “Sun Jul 20 16:17:00 EDT 1969”。</li>
</ul>
<p>[index$]不加的话默认是从左到右的顺序依次取值</p>
<p><strong>示例：</strong></p>
<pre><code>Log.d(TAG, String.format(&quot;整数:%,d&quot;, -80000000));
Log.d(TAG, String.format(&quot;浮点数:%.2f&quot;, 0.81634f));
Log.d(TAG, String.format(&quot;字符串:%s&quot;, &quot;hello word&quot;));
Log.d(TAG, String.format(&quot;布尔:%b&quot;, 8 &gt; 9));
Log.d(TAG, String.format(&quot;百分比:%%%d&quot;, 80));
Log.d(TAG, String.format(&quot;换行符:%n换行符&quot;));
Log.d(TAG, String.format(&quot;日期R:%tR&quot;, new Date()));
Log.d(TAG, String.format(&quot;日期T:%tT&quot;, new Date()));
Log.d(TAG, String.format(&quot;日期D:%tD&quot;, new Date()));
Log.d(TAG, String.format(&quot;日期F:%tF&quot;, new Date()));
Log.d(TAG, String.format(&quot;日期c:%tc&quot;, new Date()));
Log.d(TAG, String.format(&quot;日期H:%tH&quot;, new Date()));
Log.d(TAG, String.format(&quot;日期I:%tI&quot;, new Date()));
Log.d(TAG, String.format(&quot;日期k:%tk&quot;, new Date()));
Log.d(TAG, String.format(&quot;日期l:%tl&quot;, new Date()));
Log.d(TAG, String.format(&quot;整数:%,d--浮点数:%.2f--字符串:%s--布尔:%b--百分比:%%%d--换行符:%n换行符&quot;,
            -80000000, 0.81634f, &quot;hello word&quot;, 8 &gt; 9, 80));
Log.d(TAG, String.format(&quot;整数:%1$,d--浮点数:%3$.2f--字符串:%2$s--布尔:%4$b&quot;,
            -80000000, &quot;hello word&quot;, 0.81634f, 8 &gt; 9));
</code></pre><p><strong>输出</strong></p>
<pre><code>12-14 22:24:11.231    1109-1109/loody.com.helloword D/MainActivity﹕ 整数:-80,000,000
12-14 22:24:11.231    1109-1109/loody.com.helloword D/MainActivity﹕ 浮点数:0.82
12-14 22:24:11.231    1109-1109/loody.com.helloword D/MainActivity﹕ 字符串:hello word
12-14 22:24:11.231    1109-1109/loody.com.helloword D/MainActivity﹕ 布尔:false
12-14 22:24:11.231    1109-1109/loody.com.helloword D/MainActivity﹕ 百分比:%80
12-14 22:24:11.231    1109-1109/loody.com.helloword D/MainActivity﹕ 换行符:
换行符
12-14 22:24:11.231    1109-1109/loody.com.helloword D/MainActivity﹕ 日期R:22:24
12-14 22:24:11.231    1109-1109/loody.com.helloword D/MainActivity﹕ 日期T:22:24:11
12-14 22:24:11.231    1109-1109/loody.com.helloword D/MainActivity﹕ 日期D:12/14/14
12-14 22:24:11.231    1109-1109/loody.com.helloword D/MainActivity﹕ 日期F:2014-12-14
12-14 22:24:11.241    1109-1109/loody.com.helloword D/MainActivity﹕ 日期c:星期日 12月 14 22:24:11 GMT+08:00 2014
12-14 22:24:11.241    1109-1109/loody.com.helloword D/MainActivity﹕ 日期H:22
12-14 22:24:11.241    1109-1109/loody.com.helloword D/MainActivity﹕ 日期I:10
12-14 22:24:11.241    1109-1109/loody.com.helloword D/MainActivity﹕ 日期k:22
12-14 22:24:11.241    1109-1109/loody.com.helloword D/MainActivity﹕ 日期l:10
12-14 22:24:11.241    1109-1109/loody.com.helloword D/MainActivity﹕ 整数:-80,000,000--浮点数:0.82--字符串:hello word--布尔:false--百分比:%80--换行符:
换行符
12-14 22:24:11.241    1109-1109/loody.com.helloword D/MainActivity﹕ 整数:-80,000,000--浮点数:0.82--字符串:hello word--布尔:false               
</code></pre><h2 id="常见的转义符"><a href="#常见的转义符" class="headerlink" title="常见的转义符"></a>常见的转义符</h2><ul>
<li>“:双引号(\&#34;) </li>
<li>‘:单引号(\&#39;) </li>
<li>&amp;:(\&#38;) </li>
<li>小于号(&lt;):(\&#60;) </li>
<li>大于号(&gt;):(\&#62;) </li>
<li>空格：（\&#160;）</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/07/2014-12-07-about-gradle dependency management/" itemprop="url">
                  Gradle如何声明所需的依赖以及依赖的分类（分组）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-07T00:00:00+08:00" content="2014-12-07">
              2014-12-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Gradle/" itemprop="url" rel="index">
                    <span itemprop="name">Gradle</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/12/07/2014-12-07-about-gradle dependency management/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/12/07/2014-12-07-about-gradle dependency management/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近项目在采用android studio来开发，它采用的是Gradle构建系统，当我们要添加外部依赖的时候我们只需要在build.gradle下配置如下即可</p>
<pre><code>dependencies {
    compile &apos;com.android.support:appcompat-v7:21.0.2&apos;
}
</code></pre><p>但是这是什么意思呢？于是就去学习了一下granle的依赖管理，原来定义外部依赖包含group, name和version这三个属性，上面的写法是一种简洁的写法，把它补全就是</p>
<pre><code>dependencies {
    compile group:&apos;com.android.support&apos;,name:&apos;support-v4&apos;,version:&apos;21.0.2&apos;    }
</code></pre><h2 id="依赖管理简介"><a href="#依赖管理简介" class="headerlink" title="依赖管理简介"></a>依赖管理简介</h2><p>在配置完项目仓库后，我们可以声明其中的依赖，如果我们想要声明一个新的依赖，可以采用如下步骤：</p>
<p>指定依赖的配置。<br>声明所需的依赖。<br>让我们看一下详细步骤：</p>
<h2 id="配置中的依赖分类"><a href="#配置中的依赖分类" class="headerlink" title="配置中的依赖分类"></a>配置中的依赖分类</h2><p>在Gradle中，依赖是按照指定名称进行分类的，这些分类被称为配置项，我们可以使用配置项声明项目的外部依赖。</p>
<p>Java插件指定了若干依赖配置项，其描述如下：当项目的源代码被编译时，</p>
<p>compile配置项中的依赖是必须的。</p>
<p>runtime配置项中包含的依赖在运行时是必须的。</p>
<p>testCompile配置项中包含的依赖在编译项目的测试代码时是必须的。</p>
<p>testRuntime配置项中包含的依赖在运行测试代码时是必须的。</p>
<p>archives配置项中包含项目生成的文件（如Jar文件）。</p>
<p>default配置项中包含运行时必须的依赖。</p>
<h2 id="声明项目依赖"><a href="#声明项目依赖" class="headerlink" title="声明项目依赖"></a>声明项目依赖</h2><p>最普遍的依赖称为外部依赖，这些依赖存放在外部仓库中。一个外部依赖可以由以下属性指定：</p>
<p><code>group</code>属性指定依赖的分组（在Maven中，就是groupId）。</p>
<p><code>name</code>属性指定依赖的名称（在Maven中，就是artifactId）。</p>
<p><code>vertion</code>属性指定外部依赖的版本（在Maven中，就是version）。</p>
<p>我们假设我们需要指定以下依赖：</p>
<p>依赖的分组是foo。</p>
<p>依赖的名称是foo。</p>
<p>依赖的版本是0.1。</p>
<p>在项目编译时需要这些依赖。我们可以将以下代码片段加入到build.gradle中，进行依赖声明：</p>
<pre><code>dependencies {
    compile group: &apos;foo&apos;, name: &apos;foo&apos;, version: &apos;0.1&apos;
}
</code></pre><p>我们也可以采用一种快捷方式声明依赖：[group]:[name]:[version]。如果我们想用这种方式，我们可以将以下代码段加入到build.gradle中：</p>
<pre><code>dependencies {
    compile &apos;foo:foo:0.1&apos;
}
</code></pre><p>我们也可以在同一个配置项中加入多个依赖，传统的方式如下：</p>
<pre><code>dependencies {
    compile (
        [group: &apos;foo&apos;, name: &apos;foo&apos;, version: &apos;0.1&apos;],
        [group: &apos;bar&apos;, name: &apos;bar&apos;, version: &apos;0.1&apos;]
    )
}
</code></pre><p>如果采用快捷方式，那可以是这样：</p>
<pre><code>dependencies {
    compile &apos;foo:foo:0.1&apos;, &apos;bar:bar:0.1&apos;
}
</code></pre><p>自然地，声明属于不同配置项的依赖也是可以的。比如说，如果我们想要声明属于compile和testCompile配置项的依赖，可以这么做：</p>
<pre><code>dependencies {
    compile group: &apos;foo&apos;, name: &apos;foo&apos;, version: &apos;0.1&apos;
    testCompile group: &apos;test&apos;, name: &apos;test&apos;, version: &apos;0.1&apos;
}
</code></pre><p>同样的，给力的快捷方式又来了</p>
<pre><code>dependencies {
    compile &apos;foo:foo:0.1&apos;
    testCompile &apos;test:test:0.1&apos;
}                
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/15/2014-11-15-about activity lauchMode/" itemprop="url">
                  Activity的四种启动模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-15T00:00:00+08:00" content="2014-11-15">
              2014-11-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/15/2014-11-15-about activity lauchMode/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/15/2014-11-15-about activity lauchMode/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前两天在开发中碰到一些Activity重用的需求，流程如下：</p>
<p><code>MainActivity</code>–&gt;<code>FirstActivity</code>–&gt;<code>SecondActivity</code>–&gt;<code>LoginActivity</code>–&gt;<code>MainActivity</code></p>
<p>因为MainActivity是程序的主界面，一般都将其放置栈底，不可能干掉他，但是我们又要怎么回到MainActivity而又不会重新创建它呢？那就是利用Android的启动模式，下面就来简单介绍一下。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在android里，有4种activity的启动模式，分别为： </p>
<p><strong>standard</strong>: 标准模式，一调用startActivity()方法就会产生一个新的实例。</p>
<p><strong>singleTop</strong>: 如果已经有一个实例位于Activity栈的顶部时，就不产生新的实例，而只是调用Activity中的newInstance()方法。如果不位于栈顶，会产生一个新的实例。</p>
<p><strong>singleTask</strong>: 会在一个新的task中产生这个实例，以后每次调用都会使用这个，不会去产生新的实例了。</p>
<p><strong>singleInstance</strong>: 这个跟singleTask基本上是一样，只有一个区别：在这个模式下的Activity实例所处的task中，只能有这个activity实例，不能有其他的实例。</p>
<p>上面的例子中我们就可以设置MainActivity的启动模式为singleTask，这样就可以保证它单实例存在了。</p>
<h2 id="四种加载模式的区别"><a href="#四种加载模式的区别" class="headerlink" title="四种加载模式的区别"></a>四种加载模式的区别</h2><p><strong>所属task的区别</strong></p>
<p>一般情况下，“standard”和”singleTop”的activity的目标task，和收到的Intent的发送者在同一个task内，就相当于谁调用它，它就跟谁在同一个Task中。除非Intent包括参数FLAG_ACTIVITY_NEW_TASK。如果提供了FLAG_ACTIVITY_NEW_TASK参数，会启动到别的task里。<br>“singleTask”和”singleInstance” 总是把要启动的activity作为一个task的根元素，他们不会被启动到一个其他task里。</p>
<p><strong>是否允许多个实例</strong></p>
<p>“standard”和”singleTop”可以被实例化多次，并且是可以存在于不同的task中；这种实例化时一个task可以包括一个activity的多个实例；“singleTask”和”singleInstance”则限制只生成一个实例，并且是task的根元素。singleTop 要求如果创建intent的时候栈顶已经有要创建的Activity的实例，则将intent发送给该实例，而不创建新的实例。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p> 当我们调用OnNewIntent时的需要注意当前Activity可能会被后台回收，导致数据丢失，详见:<a href="http://blog.csdn.net/tyj1982/article/details/6848879" target="_blank" rel="external">http://blog.csdn.net/tyj1982/article/details/6848879</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/26/2014-10-26-about LayoutInflater/" itemprop="url">
                  Android LayoutInflater原理分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-10-26T00:00:00+08:00" content="2014-10-26">
              2014-10-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/26/2014-10-26-about LayoutInflater/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/26/2014-10-26-about LayoutInflater/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>相信接触Android久一点的朋友对于LayoutInflater一定不会陌生，都会知道它主要是用于加载布局的。而刚接触Android的朋友可能对LayoutInflater不怎么熟悉，因为加载布局的任务通常都是在Activity中调用setContentView()方法来完成的。其实setContentView()方法的内部也是使用LayoutInflater来加载布局的，只不过这部分源码是internal的，不太容易查看到。那么今天我们就来把LayoutInflater的工作流程仔细地剖析一遍，也许还能解决掉某些困扰你心头多年的疑惑。</p>
<h2 id="LayoutInflater的用法"><a href="#LayoutInflater的用法" class="headerlink" title="LayoutInflater的用法"></a>LayoutInflater的用法</h2><p>首先需要获取到LayoutInflater的实例，有两种方法可以获取到，</p>
<p>第一种写法如下：</p>
<pre><code>LayoutInflater layoutInflater = LayoutInflater.from(context);
</code></pre><p>另外一种写法：</p>
<pre><code>LayoutInflater layoutInflater = (LayoutInflater)     context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
</code></pre><p>其实第一种就是第二种的简单写法，只是Android给我们做了一下封装而已。得到了LayoutInflater的实例之后就可以调用它的inflate()方法来加载布局了，如下所示：</p>
<pre><code>layoutInflater.inflate(resourceId, root);
</code></pre><p>inflate()方法一般接收两个参数，第一个参数就是要加载的布局id，第二个参数是指给该布局的外部再嵌套一层父布局，如果不需要就直接传null。这样就成功成功创建了一个布局的实例，之后再将它添加到指定的位置就可以显示出来了。</p>
<p>下面我们就通过一个非常简单的小例子，来更加直观地看一下LayoutInflater的用法。比如说当前有一个项目，其中MainActivity对应的布局文件叫做activity_main.xml，代码如下所示：</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/main_layout&quot;
        android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; &gt;

&lt;/LinearLayout&gt;
</code></pre><p>这个布局文件的内容非常简单，只有一个空的LinearLayout，里面什么控件都没有，因此界面上应该不会显示任何东西。<br>那么接下来我们再定义一个布局文件，给它取名为button_layout.xml，代码如下所示：</p>
<pre><code>&lt;Button xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&quot;Button&quot; /&gt;
</code></pre><p>这个布局文件也非常简单，只有一个Button按钮而已。现在我们要想办法，如何通过LayoutInflater来将button_layout这个布局添加到主布局文件的LinearLayout中。根据刚刚介绍的用法，修改MainActivity中的代码，如下所示：</p>
<pre><code>public class MainActivity extends Activity {

    private LinearLayout mainLayout;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mainLayout = (LinearLayout) findViewById(R.id.main_layout);
        LayoutInflater layoutInflater = LayoutInflater.from(this);
        View buttonLayout = layoutInflater.inflate(R.layout.button_layout, null);
        mainLayout.addView(buttonLayout);
    }
}    
</code></pre><p>可以看到，这里先是获取到了LayoutInflater的实例，然后调用它的inflate()方法来加载button_layout这个布局，最后调用LinearLayout的addView()方法将它添加到LinearLayout中。<br>现在可以运行一下程序，Button在界面上显示出来了！说明我们确实是借助LayoutInflater成功将button_layout这个布局添加到LinearLayout中了。LayoutInflater技术广泛应用于需要动态添加View的时候，比如在ScrollView和ListView中，经常都可以看到LayoutInflater的身影。</p>
<p>当然，仅仅只是介绍了如何使用LayoutInflater显然是远远无法满足大家的求知欲的，知其然也要知其所以然，接下来我们就从源码的角度上看一看LayoutInflater到底是如何工作的。</p>
<p>不管你是使用的哪个inflate()方法的重载，最终都会辗转调用到LayoutInflater的如下代码中：</p>
<pre><code>public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {
synchronized (mConstructorArgs) {
    final AttributeSet attrs = Xml.asAttributeSet(parser);
    mConstructorArgs[0] = mContext;
    View result = root;
    try {
        int type;
        while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;
                type != XmlPullParser.END_DOCUMENT) {
        }
        if (type != XmlPullParser.START_TAG) {
            throw new InflateException(parser.getPositionDescription()
                    + &quot;: No start tag found!&quot;);
        }
        final String name = parser.getName();
        if (TAG_MERGE.equals(name)) {
            if (root == null || !attachToRoot) {
                throw new InflateException(&quot;merge can be used only with a valid &quot;
                        + &quot;ViewGroup root and attachToRoot=true&quot;);
            }
            rInflate(parser, root, attrs);
        } else {
            View temp = createViewFromTag(name, attrs);
            ViewGroup.LayoutParams params = null;
            if (root != null) {
                params = root.generateLayoutParams(attrs);
                if (!attachToRoot) {
                    temp.setLayoutParams(params);
                }
            }
            rInflate(parser, temp, attrs);
            if (root != null &amp;&amp; attachToRoot) {
                root.addView(temp, params);
            }
            if (root == null || !attachToRoot) {
                result = temp;
            }
        }
    } catch (XmlPullParserException e) {
        InflateException ex = new InflateException(e.getMessage());
        ex.initCause(e);
        throw ex;
    } catch (IOException e) {
        InflateException ex = new InflateException(
                parser.getPositionDescription()
                + &quot;: &quot; + e.getMessage());
        ex.initCause(e);
        throw ex;
    }
    return result;
       }
    }
</code></pre><p>从这里我们就可以清楚地看出，LayoutInflater其实就是使用Android提供的pull解析方式来解析布局文件的.这里只是创建出了一个根布局的实例而已，接下来会调用rInflate()方法来循环遍历这个根布局下的子元素，代码如下所示：</p>
<pre><code>private void rInflate(XmlPullParser parser, View parent, final AttributeSet attrs)
    throws XmlPullParserException, IOException {
final int depth = parser.getDepth();
int type;
while (((type = parser.next()) != XmlPullParser.END_TAG ||
        parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
    if (type != XmlPullParser.START_TAG) {
        continue;
    }
    final String name = parser.getName();
    if (TAG_REQUEST_FOCUS.equals(name)) {
        parseRequestFocus(parser, parent);
    } else if (TAG_INCLUDE.equals(name)) {
        if (parser.getDepth() == 0) {
            throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);
        }
        parseInclude(parser, parent, attrs);
    } else if (TAG_MERGE.equals(name)) {
        throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);
    } else {
        final View view = createViewFromTag(name, attrs);
        final ViewGroup viewGroup = (ViewGroup) parent;
        final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
        rInflate(parser, view, attrs);
        viewGroup.addView(view, params);
    }
}
    parent.onFinishInflate();
}
</code></pre><p>同样是createViewFromTag()方法来创建View的实例,然后还会递归调用rInflate()方法来查找这个View下的子元素，每次递归完成后则将这个View添加到父布局当中。这样的话，把整个布局文件都解析完成后就形成了一个完整的DOM结构，最终会把最顶层的根布局返回，至此inflate()过程全部结束。LayoutInflater的工作原理和流程就是这样</p>
<h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p> 我们觉得上面那个例子的button的大小不合适，想改变一下宽高，运行发现button的大小并没有改变，这是为什么呢？查看源码发现，inflate()方法还有个接收三个参数的方法重载，结构如下：</p>
<pre><code>inflate(int resource, ViewGroup root, boolean attachToRoot)
</code></pre><ol>
<li><p>如果root为null，attachToRoot将失去作用，设置任何值都没有意义。</p>
</li>
<li><p>如果root不为null，attachToRoot设为true，则会在加载的布局文件的最外层再嵌套一层root布局。</p>
</li>
<li><p>如果root不为null，attachToRoot设为false，则root参数失去作用。</p>
</li>
<li><p>在不设置attachToRoot参数的情况下，如果root不为null，attachToRoot参数默认为true。 </p>
</li>
</ol>
<p>上面例子中的button的情况就是第三种，不管你将Button的layout_width和layout_height的值修改成多少，都不会有任何效果的，因为这两个值现在已经完全失去了作用</p>
<p>也许有些朋友心中会有一个巨大的疑惑。不对呀！平时在Activity中指定布局文件的时候，最外层的那个布局是可以指定大小的呀，layout_width和layout_height都是有作用的。确实，这主要是因为，在setContentView()方法中，Android会自动在布局文件的最外层再嵌套一个FrameLayout，所以layout_width和layout_height属性才会有效果.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>平时我们经常使用layout_width和layout_height来设置View的大小，并且一直都能正常工作，就好像这两个属性确实是用于设置View的大小的。而实际上则不然，它们其实是用于设置View在布局中的大小的，也就是说，首先View必须存在于一个布局中，之后如果将layout_width设置成match_parent表示让View的宽度填充满布局，如果设置成wrap_content表示让View的宽度刚好可以包含其内容，如果设置成具体的数值则View的宽度会变成相应的数值。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/loofee.png"
               alt="loody" />
          <p class="site-author-name" itemprop="name">loody</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">30</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/loody" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2396231120/profile?topnav=1&wvr=6&is_all=1" target="_blank">
                  
                    <i class="fa fa-globe"></i> weibo
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">loody</span>
</div>

<div class="powered-by">
  <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

&nbsp&nbsp&nbsp本站总访问量 <span id="busuanzi_value_site_pv"></span> &nbsp&nbsp
总访客数 <span id="busuanzi_value_site_uv"></span>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"loody"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  


</body>
</html>
