<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="loody's blog">
<meta property="og:url" content="http://loody.github.io/page/3/index.html">
<meta property="og:site_name" content="loody's blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="loody's blog">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> loody's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?f99c8e8fc92fd70fbf50a1494cf47607";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">loody's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/07/2014-12-07-about-gradle dependency management/" itemprop="url">
                  Gradle如何声明所需的依赖以及依赖的分类（分组）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-07T00:00:00+08:00" content="2014-12-07">
              2014-12-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Gradle/" itemprop="url" rel="index">
                    <span itemprop="name">Gradle</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/12/07/2014-12-07-about-gradle dependency management/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/12/07/2014-12-07-about-gradle dependency management/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近项目在采用android studio来开发，它采用的是Gradle构建系统，当我们要添加外部依赖的时候我们只需要在build.gradle下配置如下即可</p>
<pre><code>dependencies {
    compile &apos;com.android.support:appcompat-v7:21.0.2&apos;
}
</code></pre><p>但是这是什么意思呢？于是就去学习了一下granle的依赖管理，原来定义外部依赖包含group, name和version这三个属性，上面的写法是一种简洁的写法，把它补全就是</p>
<pre><code>dependencies {
    compile group:&apos;com.android.support&apos;,name:&apos;support-v4&apos;,version:&apos;21.0.2&apos;    }
</code></pre><h2 id="依赖管理简介"><a href="#依赖管理简介" class="headerlink" title="依赖管理简介"></a>依赖管理简介</h2><p>在配置完项目仓库后，我们可以声明其中的依赖，如果我们想要声明一个新的依赖，可以采用如下步骤：</p>
<p>指定依赖的配置。<br>声明所需的依赖。<br>让我们看一下详细步骤：</p>
<h2 id="配置中的依赖分类"><a href="#配置中的依赖分类" class="headerlink" title="配置中的依赖分类"></a>配置中的依赖分类</h2><p>在Gradle中，依赖是按照指定名称进行分类的，这些分类被称为配置项，我们可以使用配置项声明项目的外部依赖。</p>
<p>Java插件指定了若干依赖配置项，其描述如下：当项目的源代码被编译时，</p>
<p>compile配置项中的依赖是必须的。</p>
<p>runtime配置项中包含的依赖在运行时是必须的。</p>
<p>testCompile配置项中包含的依赖在编译项目的测试代码时是必须的。</p>
<p>testRuntime配置项中包含的依赖在运行测试代码时是必须的。</p>
<p>archives配置项中包含项目生成的文件（如Jar文件）。</p>
<p>default配置项中包含运行时必须的依赖。</p>
<h2 id="声明项目依赖"><a href="#声明项目依赖" class="headerlink" title="声明项目依赖"></a>声明项目依赖</h2><p>最普遍的依赖称为外部依赖，这些依赖存放在外部仓库中。一个外部依赖可以由以下属性指定：</p>
<p><code>group</code>属性指定依赖的分组（在Maven中，就是groupId）。</p>
<p><code>name</code>属性指定依赖的名称（在Maven中，就是artifactId）。</p>
<p><code>vertion</code>属性指定外部依赖的版本（在Maven中，就是version）。</p>
<p>我们假设我们需要指定以下依赖：</p>
<p>依赖的分组是foo。</p>
<p>依赖的名称是foo。</p>
<p>依赖的版本是0.1。</p>
<p>在项目编译时需要这些依赖。我们可以将以下代码片段加入到build.gradle中，进行依赖声明：</p>
<pre><code>dependencies {
    compile group: &apos;foo&apos;, name: &apos;foo&apos;, version: &apos;0.1&apos;
}
</code></pre><p>我们也可以采用一种快捷方式声明依赖：[group]:[name]:[version]。如果我们想用这种方式，我们可以将以下代码段加入到build.gradle中：</p>
<pre><code>dependencies {
    compile &apos;foo:foo:0.1&apos;
}
</code></pre><p>我们也可以在同一个配置项中加入多个依赖，传统的方式如下：</p>
<pre><code>dependencies {
    compile (
        [group: &apos;foo&apos;, name: &apos;foo&apos;, version: &apos;0.1&apos;],
        [group: &apos;bar&apos;, name: &apos;bar&apos;, version: &apos;0.1&apos;]
    )
}
</code></pre><p>如果采用快捷方式，那可以是这样：</p>
<pre><code>dependencies {
    compile &apos;foo:foo:0.1&apos;, &apos;bar:bar:0.1&apos;
}
</code></pre><p>自然地，声明属于不同配置项的依赖也是可以的。比如说，如果我们想要声明属于compile和testCompile配置项的依赖，可以这么做：</p>
<pre><code>dependencies {
    compile group: &apos;foo&apos;, name: &apos;foo&apos;, version: &apos;0.1&apos;
    testCompile group: &apos;test&apos;, name: &apos;test&apos;, version: &apos;0.1&apos;
}
</code></pre><p>同样的，给力的快捷方式又来了</p>
<pre><code>dependencies {
    compile &apos;foo:foo:0.1&apos;
    testCompile &apos;test:test:0.1&apos;
}                
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/15/2014-11-15-about activity lauchMode/" itemprop="url">
                  Activity的四种启动模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-15T00:00:00+08:00" content="2014-11-15">
              2014-11-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/15/2014-11-15-about activity lauchMode/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/15/2014-11-15-about activity lauchMode/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前两天在开发中碰到一些Activity重用的需求，流程如下：</p>
<p><code>MainActivity</code>–&gt;<code>FirstActivity</code>–&gt;<code>SecondActivity</code>–&gt;<code>LoginActivity</code>–&gt;<code>MainActivity</code></p>
<p>因为MainActivity是程序的主界面，一般都将其放置栈底，不可能干掉他，但是我们又要怎么回到MainActivity而又不会重新创建它呢？那就是利用Android的启动模式，下面就来简单介绍一下。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在android里，有4种activity的启动模式，分别为： </p>
<p><strong>standard</strong>: 标准模式，一调用startActivity()方法就会产生一个新的实例。</p>
<p><strong>singleTop</strong>: 如果已经有一个实例位于Activity栈的顶部时，就不产生新的实例，而只是调用Activity中的newInstance()方法。如果不位于栈顶，会产生一个新的实例。</p>
<p><strong>singleTask</strong>: 会在一个新的task中产生这个实例，以后每次调用都会使用这个，不会去产生新的实例了。</p>
<p><strong>singleInstance</strong>: 这个跟singleTask基本上是一样，只有一个区别：在这个模式下的Activity实例所处的task中，只能有这个activity实例，不能有其他的实例。</p>
<p>上面的例子中我们就可以设置MainActivity的启动模式为singleTask，这样就可以保证它单实例存在了。</p>
<h2 id="四种加载模式的区别"><a href="#四种加载模式的区别" class="headerlink" title="四种加载模式的区别"></a>四种加载模式的区别</h2><p><strong>所属task的区别</strong></p>
<p>一般情况下，“standard”和”singleTop”的activity的目标task，和收到的Intent的发送者在同一个task内，就相当于谁调用它，它就跟谁在同一个Task中。除非Intent包括参数FLAG_ACTIVITY_NEW_TASK。如果提供了FLAG_ACTIVITY_NEW_TASK参数，会启动到别的task里。<br>“singleTask”和”singleInstance” 总是把要启动的activity作为一个task的根元素，他们不会被启动到一个其他task里。</p>
<p><strong>是否允许多个实例</strong></p>
<p>“standard”和”singleTop”可以被实例化多次，并且是可以存在于不同的task中；这种实例化时一个task可以包括一个activity的多个实例；“singleTask”和”singleInstance”则限制只生成一个实例，并且是task的根元素。singleTop 要求如果创建intent的时候栈顶已经有要创建的Activity的实例，则将intent发送给该实例，而不创建新的实例。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p> 当我们调用OnNewIntent时的需要注意当前Activity可能会被后台回收，导致数据丢失，详见:<a href="http://blog.csdn.net/tyj1982/article/details/6848879" target="_blank" rel="external">http://blog.csdn.net/tyj1982/article/details/6848879</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/26/2014-10-26-about LayoutInflater/" itemprop="url">
                  Android LayoutInflater原理分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-10-26T00:00:00+08:00" content="2014-10-26">
              2014-10-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/26/2014-10-26-about LayoutInflater/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/26/2014-10-26-about LayoutInflater/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>相信接触Android久一点的朋友对于LayoutInflater一定不会陌生，都会知道它主要是用于加载布局的。而刚接触Android的朋友可能对LayoutInflater不怎么熟悉，因为加载布局的任务通常都是在Activity中调用setContentView()方法来完成的。其实setContentView()方法的内部也是使用LayoutInflater来加载布局的，只不过这部分源码是internal的，不太容易查看到。那么今天我们就来把LayoutInflater的工作流程仔细地剖析一遍，也许还能解决掉某些困扰你心头多年的疑惑。</p>
<h2 id="LayoutInflater的用法"><a href="#LayoutInflater的用法" class="headerlink" title="LayoutInflater的用法"></a>LayoutInflater的用法</h2><p>首先需要获取到LayoutInflater的实例，有两种方法可以获取到，</p>
<p>第一种写法如下：</p>
<pre><code>LayoutInflater layoutInflater = LayoutInflater.from(context);
</code></pre><p>另外一种写法：</p>
<pre><code>LayoutInflater layoutInflater = (LayoutInflater)     context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
</code></pre><p>其实第一种就是第二种的简单写法，只是Android给我们做了一下封装而已。得到了LayoutInflater的实例之后就可以调用它的inflate()方法来加载布局了，如下所示：</p>
<pre><code>layoutInflater.inflate(resourceId, root);
</code></pre><p>inflate()方法一般接收两个参数，第一个参数就是要加载的布局id，第二个参数是指给该布局的外部再嵌套一层父布局，如果不需要就直接传null。这样就成功成功创建了一个布局的实例，之后再将它添加到指定的位置就可以显示出来了。</p>
<p>下面我们就通过一个非常简单的小例子，来更加直观地看一下LayoutInflater的用法。比如说当前有一个项目，其中MainActivity对应的布局文件叫做activity_main.xml，代码如下所示：</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/main_layout&quot;
        android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; &gt;

&lt;/LinearLayout&gt;
</code></pre><p>这个布局文件的内容非常简单，只有一个空的LinearLayout，里面什么控件都没有，因此界面上应该不会显示任何东西。<br>那么接下来我们再定义一个布局文件，给它取名为button_layout.xml，代码如下所示：</p>
<pre><code>&lt;Button xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&quot;Button&quot; /&gt;
</code></pre><p>这个布局文件也非常简单，只有一个Button按钮而已。现在我们要想办法，如何通过LayoutInflater来将button_layout这个布局添加到主布局文件的LinearLayout中。根据刚刚介绍的用法，修改MainActivity中的代码，如下所示：</p>
<pre><code>public class MainActivity extends Activity {

    private LinearLayout mainLayout;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mainLayout = (LinearLayout) findViewById(R.id.main_layout);
        LayoutInflater layoutInflater = LayoutInflater.from(this);
        View buttonLayout = layoutInflater.inflate(R.layout.button_layout, null);
        mainLayout.addView(buttonLayout);
    }
}    
</code></pre><p>可以看到，这里先是获取到了LayoutInflater的实例，然后调用它的inflate()方法来加载button_layout这个布局，最后调用LinearLayout的addView()方法将它添加到LinearLayout中。<br>现在可以运行一下程序，Button在界面上显示出来了！说明我们确实是借助LayoutInflater成功将button_layout这个布局添加到LinearLayout中了。LayoutInflater技术广泛应用于需要动态添加View的时候，比如在ScrollView和ListView中，经常都可以看到LayoutInflater的身影。</p>
<p>当然，仅仅只是介绍了如何使用LayoutInflater显然是远远无法满足大家的求知欲的，知其然也要知其所以然，接下来我们就从源码的角度上看一看LayoutInflater到底是如何工作的。</p>
<p>不管你是使用的哪个inflate()方法的重载，最终都会辗转调用到LayoutInflater的如下代码中：</p>
<pre><code>public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {
synchronized (mConstructorArgs) {
    final AttributeSet attrs = Xml.asAttributeSet(parser);
    mConstructorArgs[0] = mContext;
    View result = root;
    try {
        int type;
        while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;
                type != XmlPullParser.END_DOCUMENT) {
        }
        if (type != XmlPullParser.START_TAG) {
            throw new InflateException(parser.getPositionDescription()
                    + &quot;: No start tag found!&quot;);
        }
        final String name = parser.getName();
        if (TAG_MERGE.equals(name)) {
            if (root == null || !attachToRoot) {
                throw new InflateException(&quot;merge can be used only with a valid &quot;
                        + &quot;ViewGroup root and attachToRoot=true&quot;);
            }
            rInflate(parser, root, attrs);
        } else {
            View temp = createViewFromTag(name, attrs);
            ViewGroup.LayoutParams params = null;
            if (root != null) {
                params = root.generateLayoutParams(attrs);
                if (!attachToRoot) {
                    temp.setLayoutParams(params);
                }
            }
            rInflate(parser, temp, attrs);
            if (root != null &amp;&amp; attachToRoot) {
                root.addView(temp, params);
            }
            if (root == null || !attachToRoot) {
                result = temp;
            }
        }
    } catch (XmlPullParserException e) {
        InflateException ex = new InflateException(e.getMessage());
        ex.initCause(e);
        throw ex;
    } catch (IOException e) {
        InflateException ex = new InflateException(
                parser.getPositionDescription()
                + &quot;: &quot; + e.getMessage());
        ex.initCause(e);
        throw ex;
    }
    return result;
       }
    }
</code></pre><p>从这里我们就可以清楚地看出，LayoutInflater其实就是使用Android提供的pull解析方式来解析布局文件的.这里只是创建出了一个根布局的实例而已，接下来会调用rInflate()方法来循环遍历这个根布局下的子元素，代码如下所示：</p>
<pre><code>private void rInflate(XmlPullParser parser, View parent, final AttributeSet attrs)
    throws XmlPullParserException, IOException {
final int depth = parser.getDepth();
int type;
while (((type = parser.next()) != XmlPullParser.END_TAG ||
        parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
    if (type != XmlPullParser.START_TAG) {
        continue;
    }
    final String name = parser.getName();
    if (TAG_REQUEST_FOCUS.equals(name)) {
        parseRequestFocus(parser, parent);
    } else if (TAG_INCLUDE.equals(name)) {
        if (parser.getDepth() == 0) {
            throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);
        }
        parseInclude(parser, parent, attrs);
    } else if (TAG_MERGE.equals(name)) {
        throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);
    } else {
        final View view = createViewFromTag(name, attrs);
        final ViewGroup viewGroup = (ViewGroup) parent;
        final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
        rInflate(parser, view, attrs);
        viewGroup.addView(view, params);
    }
}
    parent.onFinishInflate();
}
</code></pre><p>同样是createViewFromTag()方法来创建View的实例,然后还会递归调用rInflate()方法来查找这个View下的子元素，每次递归完成后则将这个View添加到父布局当中。这样的话，把整个布局文件都解析完成后就形成了一个完整的DOM结构，最终会把最顶层的根布局返回，至此inflate()过程全部结束。LayoutInflater的工作原理和流程就是这样</p>
<h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p> 我们觉得上面那个例子的button的大小不合适，想改变一下宽高，运行发现button的大小并没有改变，这是为什么呢？查看源码发现，inflate()方法还有个接收三个参数的方法重载，结构如下：</p>
<pre><code>inflate(int resource, ViewGroup root, boolean attachToRoot)
</code></pre><ol>
<li><p>如果root为null，attachToRoot将失去作用，设置任何值都没有意义。</p>
</li>
<li><p>如果root不为null，attachToRoot设为true，则会在加载的布局文件的最外层再嵌套一层root布局。</p>
</li>
<li><p>如果root不为null，attachToRoot设为false，则root参数失去作用。</p>
</li>
<li><p>在不设置attachToRoot参数的情况下，如果root不为null，attachToRoot参数默认为true。 </p>
</li>
</ol>
<p>上面例子中的button的情况就是第三种，不管你将Button的layout_width和layout_height的值修改成多少，都不会有任何效果的，因为这两个值现在已经完全失去了作用</p>
<p>也许有些朋友心中会有一个巨大的疑惑。不对呀！平时在Activity中指定布局文件的时候，最外层的那个布局是可以指定大小的呀，layout_width和layout_height都是有作用的。确实，这主要是因为，在setContentView()方法中，Android会自动在布局文件的最外层再嵌套一个FrameLayout，所以layout_width和layout_height属性才会有效果.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>平时我们经常使用layout_width和layout_height来设置View的大小，并且一直都能正常工作，就好像这两个属性确实是用于设置View的大小的。而实际上则不然，它们其实是用于设置View在布局中的大小的，也就是说，首先View必须存在于一个布局中，之后如果将layout_width设置成match_parent表示让View的宽度填充满布局，如果设置成wrap_content表示让View的宽度刚好可以包含其内容，如果设置成具体的数值则View的宽度会变成相应的数值。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/10/19/2014-10-19-about MPAndroidChart/" itemprop="url">
                  图表库MPAndroidChart简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-10-19T00:00:00+08:00" content="2014-10-19">
              2014-10-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/19/2014-10-19-about MPAndroidChart/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/19/2014-10-19-about MPAndroidChart/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>A simple charting library for Android, supporting line-, bar-, scatter-, candlestick- and piecharts, as well as scaling, dragging, selecting and animations. Supporting Android 2.2 (API level 8) and upwards.</p>
<p>这个图表非常强大，很多属性设置起来非常方便，并且动画效果非常酷，之前用的<strong>achartengine</strong>，跟这个对比，简直low爆了，而且用起来也非常繁琐，建议大家尽早替换吧！下面以创建曲线为例作简单的讲解，其他曲线类似</p>
<p>github地址：<a href="https://github.com/PhilJay/MPAndroidChart" target="_blank" rel="external">https://github.com/PhilJay/MPAndroidChart</a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li><p>xml</p>
<pre><code>&lt;com.github.mikephil.charting.charts.LineChart
    android:id=&quot;@+id/chart&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; /&gt;

LineChart chart = (LineChart) findViewById(R.id.chart);
</code></pre></li>
<li><p>code</p>
<pre><code>LineChart chart = new LineChart(Context);
</code></pre></li>
<li><p>init data</p>
<pre><code>ArrayList&lt;String&gt; xVals = new ArrayList&lt;String&gt;();
ArrayList&lt;Entry&gt; yVals = new ArrayList&lt;Entry&gt;();

LineDataSet set1 = new LineDataSet(yVals, title + &quot;曲线&quot;);
set1.setColor(Color.RED);
set1.setCircleColor(Color.RED);
set1.setLineWidth(2f);
set1.setCircleSize(4f);
set1.setDrawCircles(true);
set1....//可以根据需求设置一系列参数，非常详细

ArrayList&lt;LineDataSet&gt; dataSets = new ArrayList&lt;LineDataSet&gt;();
dataSets.add(set1); // add the datasets 创建多个表示多根曲线
// create a data object with the datasets
LineData data = new LineData(xVals, dataSets);
//最后
chart.setData(data);
</code></pre></li>
</ul>
<h2 id="几点说明"><a href="#几点说明" class="headerlink" title="几点说明"></a>几点说明</h2><ol>
<li>为了兼容低版本动画效果，此库必须导入第三方动画库nineoldandroids.jar，如果你是以jar包的形式应用并且你的项目已经引入了nineoldandroids.jar，请将项目中的nineoldandroids.jar删除，否则项目会报错</li>
<li><p>可以直接调用方法将图表的截图保存到图库或者sd卡，非常方便</p>
<pre><code>saveToGallery(String title): Saves the current chart state as an image to the gallery.
saveToPath(String title, String pathOnSD): Saves the current chart state as an image to the specified path.
</code></pre></li>
<li><p>可以设置曲线展示动画方式（）</p>
<pre><code>animateX(int durationMillis): Animates the charts values on the horizontal axis, meaning that the chart will build up within the specified time from left to right.
animateY(int durationMillis): Animates the charts values on the vertical axis, meaning that the chart will build up within the specified time from bottom to top.
animateXY(int xDuration, int yDuration): Animates both horizontal and vertical axis, resulting in a left/right bottom/top build-up.
</code></pre></li>
<li><p>可以改变图表中图例的颜色及显示位置</p>
<pre><code>Legend legend = lineChart.getLegend();
legend.setTextColor(Color.WHITE);
legend.setPosition(LegendPosition.BELOW_CHART_CENTER);
</code></pre></li>
<li><p>可以设置图表、x轴、y轴、图例的字体</p>
<pre><code>Typeface tf = Typeface.createFromAsset(getAssets(), &quot;fonts/OpenSans-SemiboldItalic.ttf&quot;);
//图表
chart.setValueTypeface(tf);
//x轴
XLabels x = chart.getXLabels();
x.setTypeface(tf);
//y轴
YLabels y = lineChart.getYLabels();
y.setTypeface(tf);
//图例
legend.setTypeface(tf)
</code></pre></li>
<li><p>可以给图表添加 Limit Lines </p>
<pre><code>LimitLine maxLine = new LimitLine(maxValue);
maxLine.setLineWidth(4f);
maxLine.enableDashedLine(10f, 10f, 0f);
maxLine.setDrawValue(false);
maxLine.setLabelPosition(LimitLabelPosition.RIGHT);

LimitLine minLine = new LimitLine(minValue);
minLine.setLineWidth(4f);
minLine.enableDashedLine(10f, 10f, 0f);
minLine.setDrawValue(false);
minLine.setLabelPosition(LimitLabelPosition.RIGHT);

lineData.addLimitLine(maxLine);
lineData.addLimitLine(minLine);
</code></pre></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/23/2014-09-23-about android sign and muti-channel-build-tool /" itemprop="url">
                  关于android签名及渠道打包
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-09-23T00:00:00+08:00" content="2014-09-23">
              2014-09-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/09/23/2014-09-23-about android sign and muti-channel-build-tool /#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/23/2014-09-23-about android sign and muti-channel-build-tool /" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为什么要签名"><a href="#为什么要签名" class="headerlink" title="为什么要签名"></a>为什么要签名</h2><ul>
<li><p>开发Android的人这么多，完全有可能大家都把类名，包名起成了一个同样的名字，这时候如何区分？签名这时候就是起区分作用的。</p>
</li>
<li><p>由于开发商可能通过使用相同的Package Name来混淆替换已经安装的程序，签名可以保证相当名字，但是签名不同的包不被替换。</p>
</li>
<li><p>APK如果使用一个key签名，发布时另一个key签名的文件将无法安装或覆盖老的版本，这样可以防止你已安装的应用被恶意的第三方覆盖或替换掉。这样签名其实也是开发者的身份标识。交易中抵赖等事情发生时，签名可以防止抵赖的发生。</p>
</li>
</ul>
<h3 id="签名的注意事项"><a href="#签名的注意事项" class="headerlink" title="签名的注意事项"></a>签名的注意事项</h3><ul>
<li><p>Android系统要求所有的程序经过数字签名才能安装，如果没有可用的数字签名，系统将不许安装运行此程序。不管是模拟器还是真实手机。因此，在设备或者是模拟器上运行调试程序之前，必须为应用程序设置数字签名。</p>
</li>
<li><p>Android签名的数字证书不需要权威机构来认证，是开发者自己产生的数字证书，即所谓的自签名。数字证书用来标识应用程序的作者和在应用程序之间建立信任关系，而不是用来决定最终用户可以安装哪些应用程序。系统仅仅会在安装的时候测试签名证书的有效期，如果应用程序的签名是在安装之后才到期，那么应用程序仍然可以正常启用。</p>
</li>
<li><p>可以使用标准工具-Keytool and Jarsigner-生成密钥，来签名应用程序的.apk文件。签名后需使用zipalign优化程序。</p>
</li>
<li><p>模拟器开发环境，开发时通过ADB接口上传的程序会先自动被签有Debug权限，然后才传递到模拟器。Eclipse菜单的Window -&gt; Preferences -&gt; Android –&gt; Build 下显示的是我们默认的调试用的签名数字证书。</p>
</li>
<li><p>正式发布一个Android应用时，必须使用一个合适的私钥生成的数字证书来给程序签名，不能使用ADT插件或者ANT工具生成的调试证书来发布。</p>
</li>
</ul>
<h2 id="签名的步骤"><a href="#签名的步骤" class="headerlink" title="签名的步骤"></a>签名的步骤</h2><h3 id="方法一：利用命令行"><a href="#方法一：利用命令行" class="headerlink" title="方法一：利用命令行"></a>方法一：利用命令行</h3><ol>
<li><p>创建key</p>
<p> 生成keystore (如已有可直接利用)<br> 按照下面的命令行 在JAVA_HOME\bin&gt;目录下,输入:<code>keytool -genkey -alias android.keystore -keyalg RSA -validity 10000 -keystore android.keystore</code></p>
<ul>
<li><p>参数意义：</p>
<p>  -genkey 产生密钥</p>
<p>  -alias 别名</p>
<p>  -keyalg RSA 使用RSA算法对签名加密</p>
<p>  -validity 10000 有效期限10000天</p>
<p>  -keystore 密钥名</p>
</li>
</ul>
</li>
<li><p>使用步骤1中产生的key对apk签名</p>
<p> 按照下面的命令行 在JAVA_HOME\bin&gt;目录下,输入:<code>jarsigner -verbose -keystore android.keystore -signedjar demo_signed.apk demo.apk android.keystore</code></p>
</li>
</ol>
<p><strong>注意事项</strong></p>
<p><strong>android工程的bin目录下的demo.apk默认是已经使用debug用户签名的，所以不能使用上述步骤对此文件再次签名。正确步骤应该是:在工程点击右键-&gt;Android Tools-Export Unsigned Application Package导出的apk采用上述步骤签名。</strong></p>
<h3 id="方法二：使用Eclipse导出带签名的apk"><a href="#方法二：使用Eclipse导出带签名的apk" class="headerlink" title="方法二：使用Eclipse导出带签名的apk"></a>方法二：使用Eclipse导出带签名的apk</h3><p>选中project,单击右键选择Android Tools—&gt;Export Signed Application Package,按提示完成即可（没有key的先创建）</p>
<h3 id="签名之后，用zipalign-压缩对齐-优化你的APK文件。"><a href="#签名之后，用zipalign-压缩对齐-优化你的APK文件。" class="headerlink" title="签名之后，用zipalign(压缩对齐)优化你的APK文件。"></a>签名之后，用zipalign(压缩对齐)优化你的APK文件。</h3><p>未签名的apk不能使用，也不能优化。签名之后的apk谷歌推荐使用zipalign.exe(位于android-sdk-windows ools目录下)工具对其优化：<br>在JAVA_HOME\bin&gt;目录下<code>zipalign -v 4 demo_signed.apk final.apk</code><br>如上，zipalign能够使apk文件中未压缩的数据在4个字节边界上对齐（4个字节是一个性能很好的值），这样android系统就可以使用mmap()(请自行查阅这个函数的用途)函数读取文件，可以在读取资源上获得较高的性能</p>
<p>PS:</p>
<ol>
<li><p>在4个字节边界上对齐的意思就是，一般来说，是指编译器吧4个字节作为一个单位来进行读取的结果，这样的话，CPU能够对变量进行高效、快速的访问（较之前不对齐）。</p>
</li>
<li><p>对齐的根源：android系统中的Davlik虚拟机使用自己专有的格式DEX，DEX的结构是紧凑的，为了让运行时的性能更好，可以进一步用”对齐”进一步优化，但是大小一般会有所增加。</p>
</li>
</ol>
<h2 id="渠道打包"><a href="#渠道打包" class="headerlink" title="渠道打包"></a>渠道打包</h2><h3 id="为什么需要在应用程序中增加渠道信息？"><a href="#为什么需要在应用程序中增加渠道信息？" class="headerlink" title="为什么需要在应用程序中增加渠道信息？"></a>为什么需要在应用程序中增加渠道信息？</h3><p>Android应用的发布需要面对各种各样的市场，我们称之为渠道。有的时候，我们需要知道应用是从哪个渠道下载的。比如，我们可能需要统计哪些市场带来的用户量比较大。再比如，我们可能有一些盈利需要和具体的渠道进行分成。这些都是统计渠道的信息。</p>
<h3 id="一般如何在应用中加入渠道信息？"><a href="#一般如何在应用中加入渠道信息？" class="headerlink" title="一般如何在应用中加入渠道信息？"></a>一般如何在应用中加入渠道信息？</h3><p>为了统计渠道信息，就不得不在程序的某个地方加入渠道的信息，然后针对不同的渠道打不同的包。一般可以在Manifest文件中加入渠道编号，而不直接写在代码中。这样做的好处是，可以针对不同渠道，自动化去修改Manifest文件中的渠道编号，然后自动为该渠道打包。<br>Manifest文件支持Meta Data标签，建议使用这种自定义标签。例如下面的文件片段。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:versionCode=&quot;X&quot;
    android:versionName=&quot;X.X.X&quot;
    package=&quot;com.XXX&quot;&gt;
    ……
    &lt;application android:icon=&quot;@drawable/icon&quot;
    android:label=&quot;@string/app_name&quot;&gt;
    ……
    &lt;meta-data android:name=&quot;CHANNEL&quot; android:value=&quot;C_001&quot; /&gt;
    &lt;/application&gt;
&lt;/manifest&gt;
</code></pre><p>在这段代码示例中，我们在Application节点下增加了一个meta-data标签，名称是CHANNEL，值是C_001，是我们规定的一个渠道的编号。为不同的渠道打包，就要手工或者自动化修改C_001成为C_002、C_003等等其它我们定义的渠道编号，然后再打不同的包。</p>
<h3 id="如何自动化打包过程？"><a href="#如何自动化打包过程？" class="headerlink" title="如何自动化打包过程？"></a>如何自动化打包过程？</h3><p>在这里介绍一款开源的打包工具 <strong>友盟渠道打包工具 (windows .net 4.0)</strong> 目前只支持windows版本</p>
<p>github地址：<a href="https://github.com/umeng/umeng-muti-channel-build-tool" target="_blank" rel="external">https://github.com/umeng/umeng-muti-channel-build-tool</a></p>
<p>现在最新版本号为:V3.2,本次更新最大的改变是放弃了 V2.x 版本中通过 Apktool 反编译apk文件打包的方式，这种打包方式会对开发的apk文件做出大幅度的修改，可能会产生许多不兼容的问题，比如对jar包中包含资源的情况无法支持，对包含 .so 文件的apk兼容性也不好，而且在打包时 AndroidManifest.xml 文件中的特殊标签会丢失。为了解决这些问题减少对开发者apk文件的修改, 我们决定放弃这种方式，而采用直接编辑二进制的AndroidManifest.xml 文件的方式。这种方式只会修改 AndroidManifest.xml 文件，对于apk包中的资源文件和代码文件都不会做任何改变。如果打包不成功，生成的apk文件有问题，在测试阶段也可以快速发现，因为修改只会影响AndroidManifest.xml 相关的少量的设置。</p>
<h3 id="编辑渠道信息注意事项"><a href="#编辑渠道信息注意事项" class="headerlink" title="编辑渠道信息注意事项"></a>编辑渠道信息注意事项</h3><ol>
<li>编辑渠道完成后按<code>Enter</code>确认</li>
<li>常用渠道可以自行配置，模板地址：\UmengTools(Green)V3.2\V3.2\projects\template.xml(先配置好后再打开友盟打包工具)</li>
<li>左下角配置文件可以自行填写，工具会自动保存你这次打包的信息（签名及渠道信息），下次可以在主页直接切换</li>
</ol>
<p>工具界面：</p>
<p><img src="/images/umeng_package_tool.jpg" alt="umeng_package_too"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/17/2014-09-17-draw9patch/" itemprop="url">
                  NinePatch的制作与使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-09-17T00:00:00+08:00" content="2014-09-17">
              2014-09-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/09/17/2014-09-17-draw9patch/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/17/2014-09-17-draw9patch/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>与传统的png格式图片相比， 9.png 格式图片在图片四周有一圈一个像素点组成的边沿，该边沿用于对图片的可扩展区和内容显示区进行定义。 </p>
<p>这种格式的图片在android 环境下具有自适应调节大小的能力。</p>
<ol>
<li><p>允许开发人员定义可扩展区域，当需要延伸图片以填充比图片本身更大区域时，可扩展区的内容被延展。</p>
</li>
<li><p>允许开发人员定义内容显示区，用于显示文字或其他内容</p>
</li>
</ol>
<p>官网介绍地址：<a href="http://developer.android.com/tools/help/draw9patch.html" target="_blank" rel="external">http://developer.android.com/tools/help/draw9patch.html</a></p>
<p>示意图：</p>
<p><img src="/images/ninepatch_demo.jpg" alt="ninepatch_demo"></p>
<p>上下左右的四条黑线表示如下：</p>
<ol>
<li><p>左边和上边的交叉区表示可扩展区域；右边和下边的交叉区表示文字显示区域</p>
</li>
<li><p>左边和上边的黑线必须有（否则，工程会报错的）；右边和下边的黑线可无，或者只有一个</p>
</li>
<li><p>当右边和下边的黑线都没有的时候，左边和上边的交叉区不仅仅表示该区域可扩展，也表示该区域是文字显示区域</p>
</li>
<li><p>当右边或者下边的黑线没有时，显示区以其对面的黑线为准</p>
</li>
</ol>
<h2 id="制作方法"><a href="#制作方法" class="headerlink" title="制作方法"></a>制作方法</h2><p>在Android SDK目录（ANDROID_HOME）的tools文件夹下有个 <strong>draw9patch.bat</strong>的批处理文件，双击就可以打开.9图的编辑界面了，如下图：</p>
<p><img src="/images/ui_draw9patch.jpg" alt="ui_draw9patch"></p>
<p>File—&gt;Open 9-patch…,选择一张png图片，按照上面的说明即可完成.9图的制作，大家多尝试就知道啦！！现贴张我做好的图</p>
<p><img src="/images/ui_draw9patch_demo.jpg" alt="ui_draw9patch_demo"></p>
<p>ps:android自带的draw9patch用起来太痛苦了，在这里给大家推荐一款牛人写的编辑器（傻瓜式），用起来非常方便，这是教程地址：<a href="http://www.miui.com/thread-83505-1-1.html" target="_blank" rel="external">http://www.miui.com/thread-83505-1-1.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/11/2014-09-11-about universal-image-loader/" itemprop="url">
                  开源库universal-image-loader的学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-09-11T00:00:00+08:00" content="2014-09-11">
              2014-09-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/09/11/2014-09-11-about universal-image-loader/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/11/2014-09-11-about universal-image-loader/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p>UIL aims to provide a powerful, flexible and highly customizable instrument for image loading, caching and displaying. It provides a lot of configuration options and good control over the image loading and caching process.</p>
<p><img src="http://loody.github.io/images/uil_demo.png" alt="uil_demo"></p>
<p>Github：<a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="external">https://github.com/nostra13/Android-Universal-Image-Loader</a></p>
<h6 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h6><ol>
<li>多线程下载图片，图片可以来源于网络，文件系统，项目文件夹assets中以及drawable中等</li>
<li>支持随意的配置ImageLoader，例如线程池，图片下载器，内存缓存策略，硬盘缓存策略，图片显示选项以及其他的一些配置</li>
<li>支持图片的内存缓存，文件系统缓存或者SD卡缓存</li>
<li>支持图片下载过程的监听</li>
<li>根据控件(ImageView)的大小对Bitmap进行裁剪，减少Bitmap占用过多的内存</li>
<li>较好的控制图片的加载过程，例如暂停图片加载，重新开始加载图片，一般使用         ListView,GridView中，滑动过程中暂停加载图片，停止滑动的时候去加载图片</li>
<li>提供在较慢的网络下对图片进行加载</li>
</ol>
<h6 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h6><p><img src="http://loody.github.io/images/the_flow_chart.png" alt="the_flow_chart"></p>
<h6 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h6><pre><code>uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;  
</code></pre><ol>
<li>下载JAR包添加到工程libs目录下</li>
<li><p>配置Android Manifest文件</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;  
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; 
</code></pre></li>
<li><p>配置ImageLoaderConfiguration这个类实现全局ImageLoader，可以选择在Application中初始化设置该类</p>
<pre><code>ImageLoaderConfiguration config = new ImageLoaderConfiguration  
.Builder(context)  
.memoryCacheExtraOptions(480, 800) // max width, max height，即保存的每个缓存文件的最大长宽  
.discCacheExtraOptions(480, 800, CompressFormat.JPEG, 75, null) // Can slow ImageLoader, use it carefully (Better don&apos;t use it)/设置缓存的详细信息，最好不要设置这个  
.threadPoolSize(3)//线程池内加载的数量  
.threadPriority(Thread.NORM_PRIORITY - 2)  
.denyCacheImageMultipleSizesInMemory()  
.memoryCache(new UsingFreqLimitedMemoryCache(2 * 1024 * 1024)) // You can pass your own memory cache implementation/你可以通过自己的内存缓存实现  
.memoryCacheSize(2 * 1024 * 1024)    
.discCacheSize(50 * 1024 * 1024)    
.discCacheFileNameGenerator(new Md5FileNameGenerator())//将保存的时候的URI名称用MD5 加密  
.tasksProcessingOrder(QueueProcessingType.LIFO)  
.discCacheFileCount(100) //缓存的文件数量  
.discCache(new UnlimitedDiscCache(cacheDir))//自定义缓存路径  
.defaultDisplayImageOptions(DisplayImageOptions.createSimple())  
.imageDownloader(new BaseImageDownloader(context, 5 * 1000, 30 * 1000)) // connectTimeout (5 s), readTimeout (30 s)超时时间  
.writeDebugLogs() // Remove for release app  
.build();//开始构建  
</code></pre><p> 以上的配置看个人需求进行选择，不是所有都要进行配置。<br> 配置好ImageLoaderConfiguration后，调用以下方法来实现初始化：</p>
<pre><code>ImageLoader.getInstance().init(config);//全局初始化此配置 
</code></pre></li>
<li><p>使用ImageLoader加载图片</p>
<p> 使用ImageLoader进行图片加载的时候，先要实例化ImageLoader，代码如下，建议放在基类Activity中，这样不必每次都去申明</p>
<pre><code>ImageLoader imageLoader = ImageLoader.getInstance(); 
imageLoader.displayImage(...); 
//一般用这个方法比较多
imageLoader.displayImage(Stirng uri, ImageView imageView, DisplayImageOptions options );
</code></pre></li>
</ol>
<h6 id="ImageLoaderConfiguration、ImageLoader、DisplayImageOptions三者的关系"><a href="#ImageLoaderConfiguration、ImageLoader、DisplayImageOptions三者的关系" class="headerlink" title="ImageLoaderConfiguration、ImageLoader、DisplayImageOptions三者的关系"></a>ImageLoaderConfiguration、ImageLoader、DisplayImageOptions三者的关系</h6><p><strong>ImageLoaderConfiguration</strong>：针对图片缓存的全局配置，主要有线程类、缓存大小、磁盘大小、图片下载与解析、日志方面的配置。</p>
<p><strong>ImageLoader</strong>：具体下载图片，缓存图片，显示图片的具体执行类，它有两个具体的方法displayImage(…)、loadImage(…)，但是其实最终他们的实现都是displayImage(…)。</p>
<p><strong>DisplayImageOptions</strong>：用于指导每一个Imageloader根据网络图片的状态（空白、下载错误、正在下载）显示对应的图片，是否将缓存加载到磁盘上，下载完后对图片进行怎么样的处理。</p>
<p>从三者的协作关系上看，他们有点像厨房规定、厨师、客户个人口味之间的关系。ImageLoaderConfiguration就像是厨房里面的规定，每一个厨师要怎么着装，要怎么保持厨房的干净，这是针对每一个厨师都适用的规定，而且不允许个性化改变。ImageLoader就像是具体做菜的厨师，负责具体菜谱的制作。DisplayImageOptions就像每个客户的偏好，根据客户是重口味还是清淡，每一个imageLoader根据DisplayImageOptions的要求具体执行。</p>
<h6 id="Acceptable-URIs-examples"><a href="#Acceptable-URIs-examples" class="headerlink" title="Acceptable URIs examples"></a>Acceptable URIs examples</h6><pre><code>String imageUri = &quot;http://site.com/image.png&quot;; // from Web
String imageUri = &quot;file:///mnt/sdcard/image.png&quot;; // from SD card
String imageUri = &quot;content://media/external/audio/albumart/13&quot;; // from content provider
String imageUri = &quot;assets://image.png&quot;; // from assets
String imageUri = &quot;drawable://&quot; + R.drawable.img; // from drawables (non-9patch images)
</code></pre><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><ol>
<li>上述提到的2个权限必须加入，否则会出错</li>
<li>ImageLoaderConfiguration必须配置并且全局化的初始化这个配置ImageLoader.getInstance().init(config);  否则也会出现错误提示</li>
<li>ImageLoader是根据ImageView的height，width确定图片的宽高。</li>
<li><p>如果经常出现OOM（别人那边看到的，觉得很有提的必要）</p>
<ul>
<li>减少配置之中线程池的大小，(.threadPoolSize).推荐1-5;</li>
<li>使用.bitmapConfig(Bitmap.config.RGB_565)代替ARGB_8888;</li>
<li>使用.imageScaleType(ImageScaleType.IN_SAMPLE_INT)或者        try.imageScaleType(ImageScaleType.EXACTLY)；</li>
<li>避免使用RoundedBitmapDisplayer.他会创建新的ARGB_8888格式的Bitmap对象；</li>
<li>使用.memoryCache(new WeakMemoryCache())，不要使用.cacheInMemory();</li>
</ul>
</li>
</ol>
<p>参考链接</p>
<p><a href="http://blog.csdn.net/vipzjyno1/article/details/23206387" target="_blank" rel="external">http://blog.csdn.net/vipzjyno1/article/details/23206387</a><br><a href="http://www.cnblogs.com/kissazi2/p/3886563.html" target="_blank" rel="external">http://www.cnblogs.com/kissazi2/p/3886563.html</a><br><a href="http://blog.csdn.net/xiaanming/article/details/26810303" target="_blank" rel="external">http://blog.csdn.net/xiaanming/article/details/26810303</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/08/30/2014-08-30-meizu smartbar adapter 2/" itemprop="url">
                  关于魅族SmartBar的适配2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-08-30T00:00:00+08:00" content="2014-08-30">
              2014-08-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/08/30/2014-08-30-meizu smartbar adapter 2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/08/30/2014-08-30-meizu smartbar adapter 2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          顶栏与底栏同时存在及自定义底栏背景
          <div class="post-more-link text-center">
            <a class="btn" href="/2014/08/30/2014-08-30-meizu smartbar adapter 2/">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/08/18/2014-08-18-FragmentPagerAdapter&FragmentStatePagerAdapter/" itemprop="url">
                  FragmentPagerAdapter与FragmentStatePagerAdapter的区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-08-18T00:00:00+08:00" content="2014-08-18">
              2014-08-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/08/18/2014-08-18-FragmentPagerAdapter&FragmentStatePagerAdapter/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/08/18/2014-08-18-FragmentPagerAdapter&FragmentStatePagerAdapter/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> 之前在项目开发中，要实现一个图片的轮播功能，我的实现思路是ViewPager+Fragment,我使用FragmentPagerAdapter来处理多 Fragment 页面的横向滑动。不过我碰到了一个问题，即当 Fragment 对应的数据集发生改变时，我希望能够通过调用 <code>mAdapter.notifyDataSetChanged()</code>来触发 Fragment 页面使用新的数据调整或重新生成其内容，可是当我调用 notifyDataSetChanged() 后，发现什么都没发生,于是去查看源码``</p>
<p>##【ViewPager】<br>ViewPager 如其名所述，是负责翻页的一个 View。准确说是一个 ViewGroup，包含多个 View 页，在手指横向滑动屏幕时，其负责对 View 进行切换。为了生成这些 View 页，需要提供一个 PagerAdapter 来进行和数据绑定以及生成最终的 View 页。</p>
<ul>
<li><strong>setAdapter()</strong><ul>
<li>ViewPager 通过 setAdapter() 来建立与 PagerAdapter 的联系。这个联系是双向的，一方面，ViewPager 会拥有 PagerAdapter 对象，从而可以在需要时调用 PagerAdapter 的方法；另一方面，ViewPager 会在 setAdapter() 中调用 PagerAdapter 的 registerDataSetObserver() 方法，注册一个自己生成的 PagerObserver 对象，从而在 PagerAdapter 有所需要时（如notifyDataSetChanged() 或 notifyDataSetInvalidated() 时），可以调用 Observer 的 onChanged() 或 onInvalidated() 方法，从而实现 PagerAdapter 向 ViewPager 方向发送信息。</li>
</ul>
</li>
<li><strong>dataSetChanged() </strong><ul>
<li>在 PagerObserver.onChanged()，以及 PagerObserver.onInvalide() 中被调用。因此当 PagerAdapter.notifyDataSetChanged() 被触发时，ViewPager.dataSetChanged() 也可以被触发。该函数将使用 getItemPosition() 的返回值来进行判断，如果为 POSITION_UNCHANGED，则什么都不做；如果为 POSITION_NONE，则调用 PagerAdapter.destroyItem() 来去掉该对象，并设置为需要刷新 (needPopulate = true) 以便触发PagerAdapter.instantiateItem() 来生成新的对象。 </li>
</ul>
</li>
</ul>
<p>##【PagerAdapter】<br>PageAdapter 是 ViewPager 的支持者，ViewPager 将调用它来取得所需显示的页，而 PageAdapter 也会在数据变化时，通知 ViewPager。这个类也是FragmentPagerAdapter 以及 FragmentStatePagerAdapter 的基类。如果继承自该类，至少需要实现 instantiateItem(), destroyItem(), getCount() 以及 isViewFromObject()。</p>
<ul>
<li><strong>getItemPosition()</strong><ul>
<li>该函数用以返回给定对象的位置，给定对象是由 instantiateItem() 的返回值。</li>
<li>在 ViewPager.dataSetChanged() 中将对该函数的返回值进行判断，以决定是否最终触发 PagerAdapter.instantiateItem() 函数。</li>
<li>在 PagerAdapter 中的实现是直接传回 POSITION_UNCHANGED。如果该函数不被重载，则会一直返回 POSITION_UNCHANGED，从而导致 ViewPager.dataSetChanged() 被调用时，认为不必触发 PagerAdapter.instantiateItem()。很多人因为没有重载该函数，而导致调用<br>PagerAdapter.notifyDataSetChanged() 后，什么都没有发生。</li>
</ul>
</li>
<li><strong>instantiateItem()</strong><ul>
<li>在每次 ViewPager 需要一个用以显示的 Object 的时候，该函数都会被 ViewPager.addNewItem() 调用。</li>
</ul>
</li>
<li><strong>notifyDataSetChanged()</strong><ul>
<li>在数据集发生变化的时候，一般 Activity 会调用 PagerAdapter.notifyDataSetChanged()，以通知 PagerAdapter，而 PagerAdapter 则会通知在自己这里注册过的所有 DataSetObserver。其中之一就是在 ViewPager.setAdapter() 中注册过的 PageObserver。PageObserver 则进而调用 ViewPager.dataSetChanged()，从而导致 ViewPager 开始触发更新其内含 View 的操作。</li>
</ul>
</li>
</ul>
<p>##【FragmentPagerAdapter】</p>
<p>FragmentPagerAdapter 继承自 PagerAdapter。相比通用的 PagerAdapter，该类更专注于每一页均为 Fragment 的情况。如文档所述，该类内的每一个生成的 Fragment 都将保存在内存之中，因此适用于那些相对静态的页，数量也比较少的那种；如果需要处理有很多页，并且数据动态性较大、占用内存较多的情况，应该使用FragmentStatePagerAdapter。FragmentPagerAdapter 重载实现了几个必须的函数，因此来自 PagerAdapter 的函数，我们只需要实现 getCount()，即可。且，由于 FragmentPagerAdapter.instantiateItem() 的实现中，调用了一个新增的虚函数 getItem()，因此，我们还至少需要实现一个 getItem()。因此，总体上来说，相对于继承自 PagerAdapter，更方便一些。</p>
<ul>
<li><strong>getItem()</strong><ul>
<li>该类中新增的一个虚函数。函数的目的为生成新的 Fragment 对象。重载该函数时需要注意这一点。在需要时，该函数将被 instantiateItem() 所调用。</li>
<li>如果需要向 Fragment 对象传递相对静态的数据时，我们一般通过 Fragment.setArguments() 来进行，这部分代码应当放到 getItem()。它们只会在新生成 Fragment 对象时执行一遍。</li>
<li>如果需要在生成 Fragment 对象后，将数据集里面一些动态的数据传递给该 Fragment，那么，这部分代码不适合放到 getItem() 中。因为当数据集发生变化时，往往对应的 Fragment 已经生成，如果传递数据部分代码放到了 getItem() 中，这部分代码将不会被调用。这也是为什么很多人发现调用 PagerAdapter.notifyDataSetChanged() 后，getItem() 没有被调用的一个原因。</li>
</ul>
</li>
<li><strong>instantiateItem()</strong><ul>
<li>函数中判断一下要生成的 Fragment 是否已经生成过了，如果生成过了，就使用旧的，旧的将被 Fragment.attach()；如果没有，就调用 getItem() 生成一个新的，新的对象将被 FragmentTransation.add()。</li>
<li>FragmentPagerAdapter 会将所有生成的 Fragment 对象通过 FragmentManager 保存起来备用，以后需要该 Fragment 时，都会从 FragmentManager 读取，而不会再次调用 getItem() 方法。</li>
<li>如果需要在生成 Fragment 对象后，将数据集中的一些数据传递给该 Fragment，这部分代码应该放到这个函数的重载里。在我们继承的子类中，重载该函数，并调用 FragmentPagerAdapter.instantiateItem() 取得该函数返回 Fragment 对象，然后，我们该 Fragment 对象中对应的方法，将数据传递过去，然后返回该对象。</li>
<li>否则，如果将这部分传递数据的代码放到 getItem()中，在 PagerAdapter.notifyDataSetChanged() 后，这部分数据设置代码将不会被调用。</li>
</ul>
</li>
<li><strong>destroyItem()</strong><ul>
<li>该函数被调用后，会对 Fragment 进行 FragmentTransaction.detach()。这里不是 remove()，只是 detach()，因此 Fragment 还在 FragmentManager 管理中，Fragment 所占用的资源不会被释放。</li>
</ul>
</li>
</ul>
<p>##【FragmentStatePagerAdapter】</p>
<p>FragmentStatePagerAdapter 和前面的 FragmentPagerAdapter 一样，是继承子 PagerAdapter。但是，和 FragmentPagerAdapter 不一样的是，正如其类名中的 ‘State’ 所表明的含义一样，该 PagerAdapter 的实现将只保留当前页面，当页面离开视线后，就会被消除，释放其资源；而在页面需要显示时，生成新的页面(就像 ListView 的实现一样)。这么实现的好处就是当拥有大量的页面时，不必在内存中占用大量的内存。</p>
<ul>
<li><strong>getItem()</strong><ul>
<li>一个该类中新增的虚函数。</li>
<li>函数的目的为生成新的 Fragment 对象。</li>
<li>Fragment.setArguments() 这种只会在新建 Fragment 时执行一次的参数传递代码，可以放在这里。</li>
<li>由于 FragmentStatePagerAdapter.instantiateItem() 在大多数情况下，都将调用 getItem() 来生成新的对象，因此如果在该函数中放置与数据集相关的 setter 代码，基本上都可以在 instantiateItem() 被调用时执行，但这和设计意图不符。毕竟还有部分可能是不会调用 getItem() 的。因此这部分代码应该放到 instantiateItem() 中。</li>
</ul>
</li>
<li><strong>instantiateItem()</strong><ul>
<li>除非碰到 FragmentManager 刚好从 SavedState 中恢复了对应的 Fragment 的情况外，该函数将会调用 getItem() 函数，生成新的 Fragment 对象。新的对象将被 FragmentTransaction.add()。</li>
<li>FragmentStatePagerAdapter 就是通过这种方式，每次都创建一个新的 Fragment，而在不用后就立刻释放其资源，来达到节省内存占用的目的的。</li>
</ul>
</li>
<li><strong>destroyItem()</strong><ul>
<li>将 Fragment 移除，即调用 FragmentTransaction.remove()，并释放其资源。</li>
</ul>
</li>
</ul>
<p>讨论</p>
<p>之前看到一些解决办法，有的认为这是一个 bug，应该被修复；有的建议不用 FragmentPagerAdapter，而改用 FragmentStatePagerAdapter，并且重载 getItemPosition() 并返回 POSITION_NONE，以触发销毁对象以及重建对象。从上面的分析中看，后者给出的建议确实可以达到调用 notifyDataSetChanged() 后，Fragment 被以新的参数重新建立的效果。</p>
<p>但是问题在于，如果我们只能这么解决这个问题，岂不是 FragmentPagerAdapter 就用不上了？最关键的是，二者对应的情况不同。对于页面相对较少的情况，我仍旧希望能够将生成的 Fragment 保存在内存中，在需要显示的时候直接调用，而不要产生生成、销毁对象的额外的开销，这样效率更高。这种情况下，选择 FragmentPagerAdapter 是更适合，不加考虑的选择 FragmentStatePagerAdapter 是不合适的。我们不能够因噎废食。</p>
<p>因此，对于 FragmentPagerAdapter 的解决方案就是，分别重载 getItem() 以及 instantiateItem() 对象。getItem() 只用于生成新的与数据无关的 Fragment；而 instantiateItem() 函数则先调用父类中的 instantiateItem() 取得所对应的 Fragment 对象，然后，根据对应的数据，调用该对象对应的方法进行数据设置。</p>
<p>当然，不要忘记重载 getItemPosition() 函数，返回 POSITION_NONE，这个两个类的解决方案都需要的。二者不同之处在于，FragmentStatePagerAdapter 在会在因 POSITION_NONE 触发调用的 destroyItem() 中真正的释放资源，重新建立一个新的 Fragment；而 FragmentPagerAdapter 仅仅会在 destroyItem() 中 detach 这个 Fragment，在 instantiateItem() 时会使用旧的 Fragment，并触发 attach，因此没有释放资源及重建的过程。</p>
<p>这样，当 notifyDataSetChanged() 被调用后，会最终触发 instantiateItem()，而不管 getItem() 是否被调用，我们都在重载的 instantiateItem() 函数中已经将所需要的数据传递给了相应的 Fragment。在 Fragment 接下来的 onCreateView(), onStart() 以及 onResume() 的事件中，它可以正确的读取新的数据，Fragment 被成功复用了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/08/10/2014-08-10-base station positioning/" itemprop="url">
                  android的基站定位
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-08-10T00:00:00+08:00" content="2014-08-10">
              2014-08-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/08/10/2014-08-10-base station positioning/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/08/10/2014-08-10-base station positioning/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于基站定位"><a href="#关于基站定位" class="headerlink" title="关于基站定位"></a>关于基站定位</h2><p>一般应用于手机用户，手机基站定位服务又叫做移动位置服务（LBS——Location Based Service），它是通过电信移动运营商的网络（如GSM网）获取移动终端用户的位置信息（经纬度坐标），在电子地图平台的支持下，为用户提供相应服务的一种增值业务，例如目前中国移动动感地带提供的动感位置查询服务等。</p>
<h2 id="需求调研"><a href="#需求调研" class="headerlink" title="需求调研"></a>需求调研</h2><p>由于之前公司项目需要用到手机定位，公司采用的百度定位，对于百度定位，大家可以去百度开放平台查看API文档，地址是：<a href="http://developer.baidu.com/map/geosdk.htm" title="http://developer.baidu.com/map/geosdk.htm" target="_blank" rel="external"><em>http://developer.baidu.com/map/geosdk.htm</em></a>，在此就不多说，今天主要介绍基站定位的流程及一些注意事项，由于在APP使用的过程中，有很多客户反应百度定位失败的情况，为了解决这一问题，公司决定采用了外链定位策略–基站定位</p>
<h2 id="基站定位原理"><a href="#基站定位原理" class="headerlink" title="基站定位原理"></a>基站定位原理</h2><p>首先,为什么移动和联通要疯狂建设基站呢?为什么在野外比较荒凉的地方,手机没有信号呢?那就是因为,我们每个人的手机都是靠搜索基站,跟基站互相通信赖以维生的,我们从一个地方走到另一个地方,手机获取的基站就从一个换成另一个,手机是在不断的搜索中渡过自己的一生:) ，基站定位,就是靠从用户手机上获得基站的信息,然后将基站信息上传给基站定位提供商的服务器,服务器拥有这些基站所在地的经纬度信息,返回给用户,用户就知道了自己的大概位置！</p>
<h2 id="APP定位流程"><a href="#APP定位流程" class="headerlink" title="APP定位流程"></a>APP定位流程</h2><ul>
<li>程序启动时／交易发生前，发起一次<strong>百度</strong>定位请求，如果此次定位失败，则间隔10秒重新进行<strong>百度</strong>定位（总共<em>3</em>次） </li>
<li>如<strong>百度</strong>定位失败，则启动<strong>外链定位</strong>，获取移动设备搜索的基站信息，上送前置，失败后间隔10秒重新发送1次。 </li>
<li>两种定位方式都未成功获取定位信息，则此次定位失败。</li>
</ul>
<p>基站信息的组成：</p>
<pre><code>public int cellId; (cellId)//基站编号  
public int mobileCountryCode;(mcc)//国家代码   
public int mobileNetworkCode;(mnc)//网络代码  
public int locationAreaCode;(lac)//区域代码  
</code></pre><p> 各自的十六进制数拼成的字符串   lac+cellId+mcc+mnc </p>
<p>基站信息组成发送后台接口</p>
<pre><code>request:
{
    stations:&quot;18ACF27101cc0000&quot;//APP组件好的基站信息，直接转发后台
    termInfo:&quot;btpos_123456789&quot;//账号+手机唯一序列号
}
</code></pre><p>部分关键代码：注意不同运营商之间获取基站信息的差异</p>
<h2 id="中国电信"><a href="#中国电信" class="headerlink" title="中国电信"></a>中国电信</h2><pre><code>if (phoneType == TelephonyManager.PHONE_TYPE_CDMA) {
    CdmaCellLocation cdma = (CdmaCellLocation) mTelephonyManager .getCellLocation(); 
    if (cdma == null) { 
        FyLog.i(FyLog.TAG_APP_OTHERS, &quot;CdmaCellLocation is null&quot;); 
        return null; 
    } 
    cellId = cdma.getBaseStationId(); 
    lac = cdma.getNetworkId(); 
    mcc = operator.substring(0, 3); 
    mnc = String.valueOf(cdma.getSystemId()); 
} 
</code></pre><h2 id="中国联通-amp-中国移动"><a href="#中国联通-amp-中国移动" class="headerlink" title="中国联通&amp;中国移动"></a>中国联通&amp;中国移动</h2><pre><code>if(phoneType == TelephonyManager.PHONE_TYPE_GSM) {// 
    GsmCellLocation gsm = (GsmCellLocation) mTelephonyManager.getCellLocation(); 
    if (gsm == null) { 
        FyLog.i(FyLog.TAG_APP_OTHERS, &quot;GsmCellLocation is null&quot;); 
        return null; 
    } 
    cellId = gsm.getCid(); 
    lac = gsm.getLac(); 
    mcc = operator.substring(0, 3); 
    mnc = operator.substring(3, 5); 
} 
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/loofee.png"
               alt="loody" />
          <p class="site-author-name" itemprop="name">loody</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">33</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">46</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/loody" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2396231120/profile?topnav=1&wvr=6&is_all=1" target="_blank">
                  
                    <i class="fa fa-globe"></i> weibo
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">loody</span>
</div>

<div class="powered-by">
  <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"loody"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  


</body>
</html>
